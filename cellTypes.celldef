// The runtime has a UnicodeChar class that provides access to Unicode utility
// methods
fieldtype UnicodeChar : uint32 {
	extern cppname = UnicodeChar;
};

fieldtype ios : uint8 {
	extern cppname = std::ios;
};

// Entry point for adapted procedures
cell Any;
cell Procedure;
cell ListElement;
fieldtype ProcedureEntryPoint : Any* (*)(World&, Procedure*, ListElement*) {
	cppname = ProcedureEntryPoint;
};

// This is a special type
fieldtype TypeId : uint8 {
	cppname = CellTypeId;
};

// C++ garbage collector defines the meaning of this field
fieldtype GarbageState : uint8 {
	extern cppname = GarbageState;
};

fieldtype State : untypedptr {
	extern cppname = dynamic::State;
};

root cell Any typetag typeId {
	TypeId typeId;
	// This is GarbageState::GlobalConstant
	GarbageState gcState = 1;
};

preconstructed cell Unit : Any {
};

abstract cell ListElement : Any {
};

concrete internal cell Pair : ListElement {
	uint32 listLength;
	Any* car;
	Any* cdr;
};

preconstructed cell EmptyList : ListElement {
};

concrete cell String : Any {
	uint16 allocSlackBytes;
	uint32 charLength;
	uint32 byteLength;
};

variant cell InlineString : String {
	uint8 inlineData[12];
};

variant cell HeapString : String {
	SharedByteArray* heapByteArray;
};

concrete cell Symbol : Any { 
	uint32 charLength;
	uint32 byteLength;
};

variant cell InlineSymbol : Symbol {
	uint8 inlineData[12];
};

variant cell HeapSymbol : Symbol {
	SharedByteArray* heapByteArray;
};

preconstructed cell Boolean : Any {
	bool value;
};

abstract cell Number : Any {
};

concrete cell ExactInteger : Number {
	int64 value;
};

concrete cell Flonum : Number {
	double value;
};

concrete cell Char : Any {
	UnicodeChar unicodeChar;
};

concrete cell Vector : Any {
	uint32 length;
	Any** elements;
};

concrete cell Bytevector : Any {
	uint32 length;
	SharedByteArray* byteArray;
};

abstract internal cell RecordLike : Any {
	bool dataIsInline;
	bool isUndefined;
	uint32 recordClassId;
	untypedptr recordData;
};

concrete cell Procedure : RecordLike {
	ProcedureEntryPoint entryPoint;
};

// Records are internal because each record class is exposed as its own 
// first-class type in Scheme
concrete internal cell Record : RecordLike {
	untypedptr extraData;
};

concrete cell ErrorObject : Any {
	String* message;
	ListElement* irritants;
};

concrete cell Port : Any {
	bool isOwned;
	ios *stream;
};

// Internal runtime-only cell to track dynamic states with the garbage collector
// Ideally this should be at the end of the file so the compiler visible types have a consecutive type IDs. Otherwise
// the compiler will generate range metadata with a hole in the middle which is both ugly and might generate suboptimal
// code.
concrete runtime cell DynamicState : Any {
	State *state;
};
