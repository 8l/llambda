/************************************************************
 * This file is generated by typegen. Do not edit manually. *
 ************************************************************/

package io.llambda.compiler.celltype
import io.llambda

import llambda.llvmir._
import llambda.compiler.InternalCompilerErrorException

sealed abstract class CellType extends DatumFields {
  val llvmName : String
  val schemeName : String
  val irType : FirstClassType
  val supertype : Option[CellType]
  val directSubtypes : Set[CellType]

  def isTypeOrSubtypeOf(otherType : CellType) : Boolean = {
    if (otherType == this) {
      return true
    }

    supertype map (_.isTypeOrSubtypeOf(otherType)) getOrElse false
  }

  def isTypeOrSupertypeOf(otherType : CellType) : Boolean = {
    if (otherType == this) {
      return true
    }

    directSubtypes exists (_.isTypeOrSupertypeOf(otherType))
  }

  lazy val concreteTypes : Set[ConcreteCellType] = this match {
    case concreteType : ConcreteCellType => Set(concreteType)
    case abstractType => directSubtypes.flatMap(_.concreteTypes)
  }

  def genPointerBitcast(block : IrBlockBuilder)(uncastValue : IrValue) : IrValue =
    if (uncastValue.irType == PointerType(irType)) {
      uncastValue
    }
    else {
      block.bitcastTo(llvmName + "Cast")(uncastValue, PointerType(irType))
    }
  
  def genTypeCheck(startBlock : IrBlockBuilder)(valueCell : IrValue, successBlock : IrBranchTarget, failBlock : IrBranchTarget) {
    val datumValue = DatumCell.genPointerBitcast(startBlock)(valueCell)
    val typeId = DatumCell.genLoadFromTypeId(startBlock)(datumValue)

    // For every possible type ID jump to the success block
    val successEntries = concreteTypes.map { concreteType =>
      (concreteType.typeId -> successBlock)
    }

    startBlock.switch(typeId, failBlock, successEntries.toSeq : _*)
  }
}

sealed abstract class ConcreteCellType extends CellType {
  val typeId : Long
}

object CellType {
  val nextTbaaIndex = 59L
}

sealed trait DatumFields {
  val irType : FirstClassType

  val typeIdIrType = IntegerType(8)
  val typeIdTbaaIndex : Long
  val typeIdGepIndices : List[Int]

  val gcStateIrType = IntegerType(8)
  val gcStateTbaaIndex : Long
  val gcStateGepIndices : List[Int]

  def genPointerToTypeId(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("typeIdPtr")(
      elementType=typeIdIrType,
      basePointer=valueCell,
      indices=typeIdGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToTypeId(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val typeIdPtr = genPointerToTypeId(block)(valueCell)
    block.store(toStore, typeIdPtr, tbaaIndex=Some(typeIdTbaaIndex))
  }

  def genLoadFromTypeId(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val typeIdPtr = genPointerToTypeId(block)(valueCell)
    block.load("typeId")(typeIdPtr, tbaaIndex=Some(typeIdTbaaIndex))
  }

  def genPointerToGcState(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("gcStatePtr")(
      elementType=gcStateIrType,
      basePointer=valueCell,
      indices=gcStateGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToGcState(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val gcStatePtr = genPointerToGcState(block)(valueCell)
    block.store(toStore, gcStatePtr, tbaaIndex=Some(gcStateTbaaIndex))
  }

  def genLoadFromGcState(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val gcStatePtr = genPointerToGcState(block)(valueCell)
    block.load("gcState")(gcStatePtr, tbaaIndex=Some(gcStateTbaaIndex))
  }
}

object DatumCell extends CellType with DatumFields {
  val llvmName = "datum"
  val schemeName = "<datum-cell>"
  val irType = UserDefinedType("datum")
  val supertype = None
  val directSubtypes = Set[CellType](UnspecificCell, ListElementCell, StringCell, SymbolCell, BooleanCell, NumericCell, CharacterCell, VectorCell, BytevectorCell, RecordLikeCell)

  val typeIdGepIndices = List(0, 0)
  val gcStateGepIndices = List(0, 1)

  val typeIdTbaaIndex = 0L
  val gcStateTbaaIndex = 1L

  def createConstant(typeId : Long) : StructureConstant = {
    StructureConstant(List(
      IntegerConstant(typeIdIrType, typeId),
      IntegerConstant(gcStateIrType, 0)
    ), userDefinedType=Some(irType))
  }
}

sealed trait UnspecificFields extends DatumFields {
  val irType : FirstClassType
}

object UnspecificCell extends ConcreteCellType with UnspecificFields {
  val llvmName = "unspecific"
  val schemeName = "<unspecific-cell>"
  val irType = UserDefinedType("unspecific")
  val supertype = Some(DatumCell)
  val directSubtypes = Set[CellType]()

  val typeId = 0L

  val typeIdGepIndices = List(0, 0, 0)
  val gcStateGepIndices = List(0, 0, 1)

  val typeIdTbaaIndex = 2L
  val gcStateTbaaIndex = 3L
}

sealed trait ListElementFields extends DatumFields {
  val irType : FirstClassType
}

object ListElementCell extends CellType with ListElementFields {
  val llvmName = "listElement"
  val schemeName = "<list-element-cell>"
  val irType = UserDefinedType("listElement")
  val supertype = Some(DatumCell)
  val directSubtypes = Set[CellType](PairCell, EmptyListCell)

  val typeIdGepIndices = List(0, 0, 0)
  val gcStateGepIndices = List(0, 0, 1)

  val typeIdTbaaIndex = 4L
  val gcStateTbaaIndex = 5L

  def createConstant(typeId : Long) : StructureConstant = {
    StructureConstant(List(
      supertype.get.createConstant(typeId=typeId)
    ), userDefinedType=Some(irType))
  }
}

sealed trait PairFields extends ListElementFields {
  val irType : FirstClassType

  val carIrType = PointerType(UserDefinedType("datum"))
  val carTbaaIndex : Long
  val carGepIndices : List[Int]

  val cdrIrType = PointerType(UserDefinedType("datum"))
  val cdrTbaaIndex : Long
  val cdrGepIndices : List[Int]

  def genPointerToCar(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("carPtr")(
      elementType=carIrType,
      basePointer=valueCell,
      indices=carGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToCar(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val carPtr = genPointerToCar(block)(valueCell)
    block.store(toStore, carPtr, tbaaIndex=Some(carTbaaIndex))
  }

  def genLoadFromCar(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val carPtr = genPointerToCar(block)(valueCell)
    block.load("car")(carPtr, tbaaIndex=Some(carTbaaIndex))
  }

  def genPointerToCdr(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("cdrPtr")(
      elementType=cdrIrType,
      basePointer=valueCell,
      indices=cdrGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToCdr(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val cdrPtr = genPointerToCdr(block)(valueCell)
    block.store(toStore, cdrPtr, tbaaIndex=Some(cdrTbaaIndex))
  }

  def genLoadFromCdr(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val cdrPtr = genPointerToCdr(block)(valueCell)
    block.load("cdr")(cdrPtr, tbaaIndex=Some(cdrTbaaIndex))
  }
}

object PairCell extends ConcreteCellType with PairFields {
  val llvmName = "pair"
  val schemeName = "<pair-cell>"
  val irType = UserDefinedType("pair")
  val supertype = Some(ListElementCell)
  val directSubtypes = Set[CellType]()

  val typeId = 1L

  val typeIdGepIndices = List(0, 0, 0, 0)
  val gcStateGepIndices = List(0, 0, 0, 1)
  val carGepIndices = List(0, 1)
  val cdrGepIndices = List(0, 2)

  val typeIdTbaaIndex = 6L
  val gcStateTbaaIndex = 7L
  val carTbaaIndex = 8L
  val cdrTbaaIndex = 9L

  def createConstant(car : IrConstant, cdr : IrConstant) : StructureConstant = {
    if (car.irType != carIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field car")
    }

    if (cdr.irType != cdrIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field cdr")
    }

    StructureConstant(List(
      supertype.get.createConstant(typeId=typeId),
      car,
      cdr
    ), userDefinedType=Some(irType))
  }
}

sealed trait EmptyListFields extends ListElementFields {
  val irType : FirstClassType
}

object EmptyListCell extends ConcreteCellType with EmptyListFields {
  val llvmName = "emptyList"
  val schemeName = "<empty-list-cell>"
  val irType = UserDefinedType("emptyList")
  val supertype = Some(ListElementCell)
  val directSubtypes = Set[CellType]()

  val typeId = 2L

  val typeIdGepIndices = List(0, 0, 0, 0)
  val gcStateGepIndices = List(0, 0, 0, 1)

  val typeIdTbaaIndex = 10L
  val gcStateTbaaIndex = 11L
}

sealed trait StringFields extends DatumFields {
  val irType : FirstClassType

  val allocSlackBytesIrType = IntegerType(16)
  val allocSlackBytesTbaaIndex : Long
  val allocSlackBytesGepIndices : List[Int]

  val charLengthIrType = IntegerType(32)
  val charLengthTbaaIndex : Long
  val charLengthGepIndices : List[Int]

  val byteLengthIrType = IntegerType(32)
  val byteLengthTbaaIndex : Long
  val byteLengthGepIndices : List[Int]

  val utf8DataIrType = PointerType(IntegerType(8))
  val utf8DataTbaaIndex : Long
  val utf8DataGepIndices : List[Int]

  def genPointerToAllocSlackBytes(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("allocSlackBytesPtr")(
      elementType=allocSlackBytesIrType,
      basePointer=valueCell,
      indices=allocSlackBytesGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToAllocSlackBytes(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val allocSlackBytesPtr = genPointerToAllocSlackBytes(block)(valueCell)
    block.store(toStore, allocSlackBytesPtr, tbaaIndex=Some(allocSlackBytesTbaaIndex))
  }

  def genLoadFromAllocSlackBytes(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val allocSlackBytesPtr = genPointerToAllocSlackBytes(block)(valueCell)
    block.load("allocSlackBytes")(allocSlackBytesPtr, tbaaIndex=Some(allocSlackBytesTbaaIndex))
  }

  def genPointerToCharLength(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("charLengthPtr")(
      elementType=charLengthIrType,
      basePointer=valueCell,
      indices=charLengthGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToCharLength(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val charLengthPtr = genPointerToCharLength(block)(valueCell)
    block.store(toStore, charLengthPtr, tbaaIndex=Some(charLengthTbaaIndex))
  }

  def genLoadFromCharLength(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val charLengthPtr = genPointerToCharLength(block)(valueCell)
    block.load("charLength")(charLengthPtr, tbaaIndex=Some(charLengthTbaaIndex))
  }

  def genPointerToByteLength(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("byteLengthPtr")(
      elementType=byteLengthIrType,
      basePointer=valueCell,
      indices=byteLengthGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToByteLength(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val byteLengthPtr = genPointerToByteLength(block)(valueCell)
    block.store(toStore, byteLengthPtr, tbaaIndex=Some(byteLengthTbaaIndex))
  }

  def genLoadFromByteLength(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val byteLengthPtr = genPointerToByteLength(block)(valueCell)
    block.load("byteLength")(byteLengthPtr, tbaaIndex=Some(byteLengthTbaaIndex))
  }

  def genPointerToUtf8Data(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("utf8DataPtr")(
      elementType=utf8DataIrType,
      basePointer=valueCell,
      indices=utf8DataGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToUtf8Data(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val utf8DataPtr = genPointerToUtf8Data(block)(valueCell)
    block.store(toStore, utf8DataPtr, tbaaIndex=Some(utf8DataTbaaIndex))
  }

  def genLoadFromUtf8Data(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val utf8DataPtr = genPointerToUtf8Data(block)(valueCell)
    block.load("utf8Data")(utf8DataPtr, tbaaIndex=Some(utf8DataTbaaIndex))
  }
}

object StringCell extends ConcreteCellType with StringFields {
  val llvmName = "string"
  val schemeName = "<string-cell>"
  val irType = UserDefinedType("string")
  val supertype = Some(DatumCell)
  val directSubtypes = Set[CellType]()

  val typeId = 3L

  val typeIdGepIndices = List(0, 0, 0)
  val gcStateGepIndices = List(0, 0, 1)
  val allocSlackBytesGepIndices = List(0, 1)
  val charLengthGepIndices = List(0, 2)
  val byteLengthGepIndices = List(0, 3)
  val utf8DataGepIndices = List(0, 4)

  val typeIdTbaaIndex = 12L
  val gcStateTbaaIndex = 13L
  val allocSlackBytesTbaaIndex = 14L
  val charLengthTbaaIndex = 15L
  val byteLengthTbaaIndex = 16L
  val utf8DataTbaaIndex = 17L

  def createConstant(allocSlackBytes : Long, charLength : Long, byteLength : Long, utf8Data : IrConstant) : StructureConstant = {
    if (utf8Data.irType != utf8DataIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field utf8Data")
    }

    StructureConstant(List(
      supertype.get.createConstant(typeId=typeId),
      IntegerConstant(allocSlackBytesIrType, allocSlackBytes),
      IntegerConstant(charLengthIrType, charLength),
      IntegerConstant(byteLengthIrType, byteLength),
      utf8Data
    ), userDefinedType=Some(irType))
  }
}

sealed trait SymbolFields extends DatumFields {
  val irType : FirstClassType

  val charLengthIrType = IntegerType(32)
  val charLengthTbaaIndex : Long
  val charLengthGepIndices : List[Int]

  val byteLengthIrType = IntegerType(32)
  val byteLengthTbaaIndex : Long
  val byteLengthGepIndices : List[Int]

  val utf8DataIrType = PointerType(IntegerType(8))
  val utf8DataTbaaIndex : Long
  val utf8DataGepIndices : List[Int]

  def genPointerToCharLength(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("charLengthPtr")(
      elementType=charLengthIrType,
      basePointer=valueCell,
      indices=charLengthGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToCharLength(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val charLengthPtr = genPointerToCharLength(block)(valueCell)
    block.store(toStore, charLengthPtr, tbaaIndex=Some(charLengthTbaaIndex))
  }

  def genLoadFromCharLength(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val charLengthPtr = genPointerToCharLength(block)(valueCell)
    block.load("charLength")(charLengthPtr, tbaaIndex=Some(charLengthTbaaIndex))
  }

  def genPointerToByteLength(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("byteLengthPtr")(
      elementType=byteLengthIrType,
      basePointer=valueCell,
      indices=byteLengthGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToByteLength(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val byteLengthPtr = genPointerToByteLength(block)(valueCell)
    block.store(toStore, byteLengthPtr, tbaaIndex=Some(byteLengthTbaaIndex))
  }

  def genLoadFromByteLength(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val byteLengthPtr = genPointerToByteLength(block)(valueCell)
    block.load("byteLength")(byteLengthPtr, tbaaIndex=Some(byteLengthTbaaIndex))
  }

  def genPointerToUtf8Data(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("utf8DataPtr")(
      elementType=utf8DataIrType,
      basePointer=valueCell,
      indices=utf8DataGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToUtf8Data(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val utf8DataPtr = genPointerToUtf8Data(block)(valueCell)
    block.store(toStore, utf8DataPtr, tbaaIndex=Some(utf8DataTbaaIndex))
  }

  def genLoadFromUtf8Data(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val utf8DataPtr = genPointerToUtf8Data(block)(valueCell)
    block.load("utf8Data")(utf8DataPtr, tbaaIndex=Some(utf8DataTbaaIndex))
  }
}

object SymbolCell extends ConcreteCellType with SymbolFields {
  val llvmName = "symbol"
  val schemeName = "<symbol-cell>"
  val irType = UserDefinedType("symbol")
  val supertype = Some(DatumCell)
  val directSubtypes = Set[CellType]()

  val typeId = 4L

  val typeIdGepIndices = List(0, 0, 0)
  val gcStateGepIndices = List(0, 0, 1)
  val charLengthGepIndices = List(0, 1)
  val byteLengthGepIndices = List(0, 2)
  val utf8DataGepIndices = List(0, 3)

  val typeIdTbaaIndex = 18L
  val gcStateTbaaIndex = 19L
  val charLengthTbaaIndex = 20L
  val byteLengthTbaaIndex = 21L
  val utf8DataTbaaIndex = 22L

  def createConstant(charLength : Long, byteLength : Long, utf8Data : IrConstant) : StructureConstant = {
    if (utf8Data.irType != utf8DataIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field utf8Data")
    }

    StructureConstant(List(
      supertype.get.createConstant(typeId=typeId),
      IntegerConstant(charLengthIrType, charLength),
      IntegerConstant(byteLengthIrType, byteLength),
      utf8Data
    ), userDefinedType=Some(irType))
  }
}

sealed trait BooleanFields extends DatumFields {
  val irType : FirstClassType

  val valueIrType = IntegerType(8)
  val valueTbaaIndex : Long
  val valueGepIndices : List[Int]

  def genPointerToValue(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("valuePtr")(
      elementType=valueIrType,
      basePointer=valueCell,
      indices=valueGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToValue(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val valuePtr = genPointerToValue(block)(valueCell)
    block.store(toStore, valuePtr, tbaaIndex=Some(valueTbaaIndex))
  }

  def genLoadFromValue(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val valuePtr = genPointerToValue(block)(valueCell)
    block.load("value")(valuePtr, tbaaIndex=Some(valueTbaaIndex))
  }
}

object BooleanCell extends ConcreteCellType with BooleanFields {
  val llvmName = "boolean"
  val schemeName = "<boolean-cell>"
  val irType = UserDefinedType("boolean")
  val supertype = Some(DatumCell)
  val directSubtypes = Set[CellType]()

  val typeId = 5L

  val typeIdGepIndices = List(0, 0, 0)
  val gcStateGepIndices = List(0, 0, 1)
  val valueGepIndices = List(0, 1)

  val typeIdTbaaIndex = 23L
  val gcStateTbaaIndex = 24L
  val valueTbaaIndex = 25L
}

sealed trait NumericFields extends DatumFields {
  val irType : FirstClassType
}

object NumericCell extends CellType with NumericFields {
  val llvmName = "numeric"
  val schemeName = "<numeric-cell>"
  val irType = UserDefinedType("numeric")
  val supertype = Some(DatumCell)
  val directSubtypes = Set[CellType](ExactIntegerCell, InexactRationalCell)

  val typeIdGepIndices = List(0, 0, 0)
  val gcStateGepIndices = List(0, 0, 1)

  val typeIdTbaaIndex = 26L
  val gcStateTbaaIndex = 27L

  def createConstant(typeId : Long) : StructureConstant = {
    StructureConstant(List(
      supertype.get.createConstant(typeId=typeId)
    ), userDefinedType=Some(irType))
  }
}

sealed trait ExactIntegerFields extends NumericFields {
  val irType : FirstClassType

  val valueIrType = IntegerType(64)
  val valueTbaaIndex : Long
  val valueGepIndices : List[Int]

  def genPointerToValue(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("valuePtr")(
      elementType=valueIrType,
      basePointer=valueCell,
      indices=valueGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToValue(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val valuePtr = genPointerToValue(block)(valueCell)
    block.store(toStore, valuePtr, tbaaIndex=Some(valueTbaaIndex))
  }

  def genLoadFromValue(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val valuePtr = genPointerToValue(block)(valueCell)
    block.load("value")(valuePtr, tbaaIndex=Some(valueTbaaIndex))
  }
}

object ExactIntegerCell extends ConcreteCellType with ExactIntegerFields {
  val llvmName = "exactInteger"
  val schemeName = "<exact-integer-cell>"
  val irType = UserDefinedType("exactInteger")
  val supertype = Some(NumericCell)
  val directSubtypes = Set[CellType]()

  val typeId = 6L

  val typeIdGepIndices = List(0, 0, 0, 0)
  val gcStateGepIndices = List(0, 0, 0, 1)
  val valueGepIndices = List(0, 1)

  val typeIdTbaaIndex = 28L
  val gcStateTbaaIndex = 29L
  val valueTbaaIndex = 30L

  def createConstant(value : Long) : StructureConstant = {
    StructureConstant(List(
      supertype.get.createConstant(typeId=typeId),
      IntegerConstant(valueIrType, value)
    ), userDefinedType=Some(irType))
  }
}

sealed trait InexactRationalFields extends NumericFields {
  val irType : FirstClassType

  val valueIrType = DoubleType
  val valueTbaaIndex : Long
  val valueGepIndices : List[Int]

  def genPointerToValue(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("valuePtr")(
      elementType=valueIrType,
      basePointer=valueCell,
      indices=valueGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToValue(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val valuePtr = genPointerToValue(block)(valueCell)
    block.store(toStore, valuePtr, tbaaIndex=Some(valueTbaaIndex))
  }

  def genLoadFromValue(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val valuePtr = genPointerToValue(block)(valueCell)
    block.load("value")(valuePtr, tbaaIndex=Some(valueTbaaIndex))
  }
}

object InexactRationalCell extends ConcreteCellType with InexactRationalFields {
  val llvmName = "inexactRational"
  val schemeName = "<inexact-rational-cell>"
  val irType = UserDefinedType("inexactRational")
  val supertype = Some(NumericCell)
  val directSubtypes = Set[CellType]()

  val typeId = 7L

  val typeIdGepIndices = List(0, 0, 0, 0)
  val gcStateGepIndices = List(0, 0, 0, 1)
  val valueGepIndices = List(0, 1)

  val typeIdTbaaIndex = 31L
  val gcStateTbaaIndex = 32L
  val valueTbaaIndex = 33L

  def createConstant(value : IrConstant) : StructureConstant = {
    if (value.irType != valueIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field value")
    }

    StructureConstant(List(
      supertype.get.createConstant(typeId=typeId),
      value
    ), userDefinedType=Some(irType))
  }
}

sealed trait CharacterFields extends DatumFields {
  val irType : FirstClassType

  val unicodeCharIrType = IntegerType(32)
  val unicodeCharTbaaIndex : Long
  val unicodeCharGepIndices : List[Int]

  def genPointerToUnicodeChar(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("unicodeCharPtr")(
      elementType=unicodeCharIrType,
      basePointer=valueCell,
      indices=unicodeCharGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToUnicodeChar(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val unicodeCharPtr = genPointerToUnicodeChar(block)(valueCell)
    block.store(toStore, unicodeCharPtr, tbaaIndex=Some(unicodeCharTbaaIndex))
  }

  def genLoadFromUnicodeChar(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val unicodeCharPtr = genPointerToUnicodeChar(block)(valueCell)
    block.load("unicodeChar")(unicodeCharPtr, tbaaIndex=Some(unicodeCharTbaaIndex))
  }
}

object CharacterCell extends ConcreteCellType with CharacterFields {
  val llvmName = "character"
  val schemeName = "<character-cell>"
  val irType = UserDefinedType("character")
  val supertype = Some(DatumCell)
  val directSubtypes = Set[CellType]()

  val typeId = 8L

  val typeIdGepIndices = List(0, 0, 0)
  val gcStateGepIndices = List(0, 0, 1)
  val unicodeCharGepIndices = List(0, 1)

  val typeIdTbaaIndex = 34L
  val gcStateTbaaIndex = 35L
  val unicodeCharTbaaIndex = 36L

  def createConstant(unicodeChar : Long) : StructureConstant = {
    StructureConstant(List(
      supertype.get.createConstant(typeId=typeId),
      IntegerConstant(unicodeCharIrType, unicodeChar)
    ), userDefinedType=Some(irType))
  }
}

sealed trait VectorFields extends DatumFields {
  val irType : FirstClassType

  val lengthIrType = IntegerType(32)
  val lengthTbaaIndex : Long
  val lengthGepIndices : List[Int]

  val elementsIrType = PointerType(PointerType(UserDefinedType("datum")))
  val elementsTbaaIndex : Long
  val elementsGepIndices : List[Int]

  def genPointerToLength(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("lengthPtr")(
      elementType=lengthIrType,
      basePointer=valueCell,
      indices=lengthGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToLength(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val lengthPtr = genPointerToLength(block)(valueCell)
    block.store(toStore, lengthPtr, tbaaIndex=Some(lengthTbaaIndex))
  }

  def genLoadFromLength(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val lengthPtr = genPointerToLength(block)(valueCell)
    block.load("length")(lengthPtr, tbaaIndex=Some(lengthTbaaIndex))
  }

  def genPointerToElements(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("elementsPtr")(
      elementType=elementsIrType,
      basePointer=valueCell,
      indices=elementsGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToElements(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val elementsPtr = genPointerToElements(block)(valueCell)
    block.store(toStore, elementsPtr, tbaaIndex=Some(elementsTbaaIndex))
  }

  def genLoadFromElements(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val elementsPtr = genPointerToElements(block)(valueCell)
    block.load("elements")(elementsPtr, tbaaIndex=Some(elementsTbaaIndex))
  }
}

object VectorCell extends ConcreteCellType with VectorFields {
  val llvmName = "vector"
  val schemeName = "<vector-cell>"
  val irType = UserDefinedType("vector")
  val supertype = Some(DatumCell)
  val directSubtypes = Set[CellType]()

  val typeId = 9L

  val typeIdGepIndices = List(0, 0, 0)
  val gcStateGepIndices = List(0, 0, 1)
  val lengthGepIndices = List(0, 1)
  val elementsGepIndices = List(0, 2)

  val typeIdTbaaIndex = 37L
  val gcStateTbaaIndex = 38L
  val lengthTbaaIndex = 39L
  val elementsTbaaIndex = 40L

  def createConstant(length : Long, elements : IrConstant) : StructureConstant = {
    if (elements.irType != elementsIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field elements")
    }

    StructureConstant(List(
      supertype.get.createConstant(typeId=typeId),
      IntegerConstant(lengthIrType, length),
      elements
    ), userDefinedType=Some(irType))
  }
}

sealed trait BytevectorFields extends DatumFields {
  val irType : FirstClassType

  val lengthIrType = IntegerType(32)
  val lengthTbaaIndex : Long
  val lengthGepIndices : List[Int]

  val dataIrType = PointerType(IntegerType(8))
  val dataTbaaIndex : Long
  val dataGepIndices : List[Int]

  def genPointerToLength(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("lengthPtr")(
      elementType=lengthIrType,
      basePointer=valueCell,
      indices=lengthGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToLength(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val lengthPtr = genPointerToLength(block)(valueCell)
    block.store(toStore, lengthPtr, tbaaIndex=Some(lengthTbaaIndex))
  }

  def genLoadFromLength(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val lengthPtr = genPointerToLength(block)(valueCell)
    block.load("length")(lengthPtr, tbaaIndex=Some(lengthTbaaIndex))
  }

  def genPointerToData(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("dataPtr")(
      elementType=dataIrType,
      basePointer=valueCell,
      indices=dataGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToData(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val dataPtr = genPointerToData(block)(valueCell)
    block.store(toStore, dataPtr, tbaaIndex=Some(dataTbaaIndex))
  }

  def genLoadFromData(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val dataPtr = genPointerToData(block)(valueCell)
    block.load("data")(dataPtr, tbaaIndex=Some(dataTbaaIndex))
  }
}

object BytevectorCell extends ConcreteCellType with BytevectorFields {
  val llvmName = "bytevector"
  val schemeName = "<bytevector-cell>"
  val irType = UserDefinedType("bytevector")
  val supertype = Some(DatumCell)
  val directSubtypes = Set[CellType]()

  val typeId = 10L

  val typeIdGepIndices = List(0, 0, 0)
  val gcStateGepIndices = List(0, 0, 1)
  val lengthGepIndices = List(0, 1)
  val dataGepIndices = List(0, 2)

  val typeIdTbaaIndex = 41L
  val gcStateTbaaIndex = 42L
  val lengthTbaaIndex = 43L
  val dataTbaaIndex = 44L

  def createConstant(length : Long, data : IrConstant) : StructureConstant = {
    if (data.irType != dataIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field data")
    }

    StructureConstant(List(
      supertype.get.createConstant(typeId=typeId),
      IntegerConstant(lengthIrType, length),
      data
    ), userDefinedType=Some(irType))
  }
}

sealed trait RecordLikeFields extends DatumFields {
  val irType : FirstClassType

  val recordClassIdIrType = IntegerType(32)
  val recordClassIdTbaaIndex : Long
  val recordClassIdGepIndices : List[Int]

  val recordDataIrType = PointerType(IntegerType(8))
  val recordDataTbaaIndex : Long
  val recordDataGepIndices : List[Int]

  def genPointerToRecordClassId(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("recordClassIdPtr")(
      elementType=recordClassIdIrType,
      basePointer=valueCell,
      indices=recordClassIdGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToRecordClassId(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val recordClassIdPtr = genPointerToRecordClassId(block)(valueCell)
    block.store(toStore, recordClassIdPtr, tbaaIndex=Some(recordClassIdTbaaIndex))
  }

  def genLoadFromRecordClassId(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val recordClassIdPtr = genPointerToRecordClassId(block)(valueCell)
    block.load("recordClassId")(recordClassIdPtr, tbaaIndex=Some(recordClassIdTbaaIndex))
  }

  def genPointerToRecordData(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("recordDataPtr")(
      elementType=recordDataIrType,
      basePointer=valueCell,
      indices=recordDataGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToRecordData(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val recordDataPtr = genPointerToRecordData(block)(valueCell)
    block.store(toStore, recordDataPtr, tbaaIndex=Some(recordDataTbaaIndex))
  }

  def genLoadFromRecordData(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val recordDataPtr = genPointerToRecordData(block)(valueCell)
    block.load("recordData")(recordDataPtr, tbaaIndex=Some(recordDataTbaaIndex))
  }
}

object RecordLikeCell extends CellType with RecordLikeFields {
  val llvmName = "recordLike"
  val schemeName = "<record-like-cell>"
  val irType = UserDefinedType("recordLike")
  val supertype = Some(DatumCell)
  val directSubtypes = Set[CellType](ProcedureCell, RecordCell)

  val typeIdGepIndices = List(0, 0, 0)
  val gcStateGepIndices = List(0, 0, 1)
  val recordClassIdGepIndices = List(0, 1)
  val recordDataGepIndices = List(0, 2)

  val typeIdTbaaIndex = 45L
  val gcStateTbaaIndex = 46L
  val recordClassIdTbaaIndex = 47L
  val recordDataTbaaIndex = 48L

  def createConstant(recordClassId : Long, recordData : IrConstant, typeId : Long) : StructureConstant = {
    if (recordData.irType != recordDataIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field recordData")
    }

    StructureConstant(List(
      supertype.get.createConstant(typeId=typeId),
      IntegerConstant(recordClassIdIrType, recordClassId),
      recordData
    ), userDefinedType=Some(irType))
  }
}

sealed trait ProcedureFields extends RecordLikeFields {
  val irType : FirstClassType

  val entryPointIrType = PointerType(FunctionType(PointerType(UserDefinedType("datum")), List(PointerType(UserDefinedType("procedure")), PointerType(UserDefinedType("listElement")))))
  val entryPointTbaaIndex : Long
  val entryPointGepIndices : List[Int]

  def genPointerToEntryPoint(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("entryPointPtr")(
      elementType=entryPointIrType,
      basePointer=valueCell,
      indices=entryPointGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToEntryPoint(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val entryPointPtr = genPointerToEntryPoint(block)(valueCell)
    block.store(toStore, entryPointPtr, tbaaIndex=Some(entryPointTbaaIndex))
  }

  def genLoadFromEntryPoint(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val entryPointPtr = genPointerToEntryPoint(block)(valueCell)
    block.load("entryPoint")(entryPointPtr, tbaaIndex=Some(entryPointTbaaIndex))
  }
}

object ProcedureCell extends ConcreteCellType with ProcedureFields {
  val llvmName = "procedure"
  val schemeName = "<procedure-cell>"
  val irType = UserDefinedType("procedure")
  val supertype = Some(RecordLikeCell)
  val directSubtypes = Set[CellType]()

  val typeId = 11L

  val typeIdGepIndices = List(0, 0, 0, 0)
  val gcStateGepIndices = List(0, 0, 0, 1)
  val recordClassIdGepIndices = List(0, 0, 1)
  val recordDataGepIndices = List(0, 0, 2)
  val entryPointGepIndices = List(0, 1)

  val typeIdTbaaIndex = 49L
  val gcStateTbaaIndex = 50L
  val recordClassIdTbaaIndex = 51L
  val recordDataTbaaIndex = 52L
  val entryPointTbaaIndex = 53L

  def createConstant(entryPoint : IrConstant, recordClassId : Long, recordData : IrConstant) : StructureConstant = {
    if (entryPoint.irType != entryPointIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field entryPoint")
    }

    StructureConstant(List(
      supertype.get.createConstant(recordClassId=recordClassId, recordData=recordData, typeId=typeId),
      entryPoint
    ), userDefinedType=Some(irType))
  }
}

sealed trait RecordFields extends RecordLikeFields {
  val irType : FirstClassType

  val extraDataIrType = PointerType(IntegerType(8))
  val extraDataTbaaIndex : Long
  val extraDataGepIndices : List[Int]

  def genPointerToExtraData(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("extraDataPtr")(
      elementType=extraDataIrType,
      basePointer=valueCell,
      indices=extraDataGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToExtraData(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val extraDataPtr = genPointerToExtraData(block)(valueCell)
    block.store(toStore, extraDataPtr, tbaaIndex=Some(extraDataTbaaIndex))
  }

  def genLoadFromExtraData(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val extraDataPtr = genPointerToExtraData(block)(valueCell)
    block.load("extraData")(extraDataPtr, tbaaIndex=Some(extraDataTbaaIndex))
  }
}

object RecordCell extends ConcreteCellType with RecordFields {
  val llvmName = "record"
  val schemeName = "<record-cell>"
  val irType = UserDefinedType("record")
  val supertype = Some(RecordLikeCell)
  val directSubtypes = Set[CellType]()

  val typeId = 12L

  val typeIdGepIndices = List(0, 0, 0, 0)
  val gcStateGepIndices = List(0, 0, 0, 1)
  val recordClassIdGepIndices = List(0, 0, 1)
  val recordDataGepIndices = List(0, 0, 2)
  val extraDataGepIndices = List(0, 1)

  val typeIdTbaaIndex = 54L
  val gcStateTbaaIndex = 55L
  val recordClassIdTbaaIndex = 56L
  val recordDataTbaaIndex = 57L
  val extraDataTbaaIndex = 58L

  def createConstant(extraData : IrConstant, recordClassId : Long, recordData : IrConstant) : StructureConstant = {
    if (extraData.irType != extraDataIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field extraData")
    }

    StructureConstant(List(
      supertype.get.createConstant(recordClassId=recordClassId, recordData=recordData, typeId=typeId),
      extraData
    ), userDefinedType=Some(irType))
  }
}

