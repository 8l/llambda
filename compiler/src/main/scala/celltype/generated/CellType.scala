/************************************************************
 * This file is generated by typegen. Do not edit manually. *
 ************************************************************/

package io.llambda.compiler.celltype
import io.llambda

import llambda.llvmir._
import llambda.compiler.InternalCompilerErrorException

sealed abstract class CastableValue {
  val irType : FirstClassType
  val llvmName : String
  
  def genPointerBitcast(block : IrBlockBuilder)(uncastValue : IrValue) : IrValue =
    if (uncastValue.irType == PointerType(irType)) {
      uncastValue
    }
    else {
      block.bitcastTo(llvmName + "Cast")(uncastValue, PointerType(irType))
    }
}

sealed abstract class CellType extends CastableValue with DatumFields {
  val schemeName : String
  val supertype : Option[CellType]
  val directSubtypes : Set[CellType]

  def isTypeOrSubtypeOf(otherType : CellType) : Boolean = {
    if (otherType == this) {
      return true
    }

    supertype map (_.isTypeOrSubtypeOf(otherType)) getOrElse false
  }

  def isTypeOrSupertypeOf(otherType : CellType) : Boolean = {
    if (otherType == this) {
      return true
    }

    directSubtypes exists (_.isTypeOrSupertypeOf(otherType))
  }

  lazy val concreteTypes : Set[ConcreteCellType] = this match {
    case concreteType : ConcreteCellType => Set(concreteType)
    case abstractType => directSubtypes.flatMap(_.concreteTypes)
  }

  def genTypeCheck(startBlock : IrBlockBuilder)(valueCell : IrValue, successBlock : IrBranchTarget, failBlock : IrBranchTarget) {
    val datumValue = DatumCell.genPointerBitcast(startBlock)(valueCell)
    val typeId = DatumCell.genLoadFromTypeId(startBlock)(datumValue)

    // For every possible type ID jump to the success block
    val successEntries = concreteTypes.map { concreteType =>
      (concreteType.typeId -> successBlock)
    }

    startBlock.switch(typeId, failBlock, successEntries.toSeq : _*)
  }
}

sealed abstract class ConcreteCellType extends CellType {
  val typeId : Long
}

sealed abstract class CellTypeVariant extends CastableValue

object CellType {
  val nextTbaaIndex = 78L
}

sealed trait DatumFields {
  val irType : FirstClassType

  val typeIdIrType = IntegerType(8)
  val typeIdTbaaIndex : Long
  val typeIdGepIndices : List[Int]

  val gcStateIrType = IntegerType(8)
  val gcStateTbaaIndex : Long
  val gcStateGepIndices : List[Int]

  def genPointerToTypeId(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("typeIdPtr")(
      elementType=typeIdIrType,
      basePointer=valueCell,
      indices=typeIdGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToTypeId(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val typeIdPtr = genPointerToTypeId(block)(valueCell)
    block.store(toStore, typeIdPtr, tbaaIndex=Some(typeIdTbaaIndex))
  }

  def genLoadFromTypeId(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val typeIdPtr = genPointerToTypeId(block)(valueCell)
    block.load("typeId")(typeIdPtr, tbaaIndex=Some(typeIdTbaaIndex))
  }

  def genPointerToGcState(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("gcStatePtr")(
      elementType=gcStateIrType,
      basePointer=valueCell,
      indices=gcStateGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToGcState(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val gcStatePtr = genPointerToGcState(block)(valueCell)
    block.store(toStore, gcStatePtr, tbaaIndex=Some(gcStateTbaaIndex))
  }

  def genLoadFromGcState(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val gcStatePtr = genPointerToGcState(block)(valueCell)
    block.load("gcState")(gcStatePtr, tbaaIndex=Some(gcStateTbaaIndex))
  }
}

object DatumCell extends CellType with DatumFields {
  val llvmName = "datum"
  val irType = UserDefinedType("datum")
  val schemeName = "<datum-cell>"
  val supertype = None
  val directSubtypes = Set[CellType](UnitCell, ListElementCell, StringCell, SymbolCell, BooleanCell, NumericCell, CharacterCell, VectorCell, BytevectorCell, RecordLikeCell, ErrorObjectCell)

  val typeIdGepIndices = List(0, 0)
  val gcStateGepIndices = List(0, 1)

  val typeIdTbaaIndex = 10L
  val gcStateTbaaIndex = 11L

  def createConstant(typeId : Long) : StructureConstant = {
    StructureConstant(List(
      IntegerConstant(typeIdIrType, typeId),
      IntegerConstant(gcStateIrType, 1)
    ), userDefinedType=Some(irType))
  }
}

sealed trait UnitFields extends DatumFields {
  val irType : FirstClassType
}

object UnitCell extends ConcreteCellType with UnitFields {
  val llvmName = "unit"
  val irType = UserDefinedType("unit")
  val schemeName = "<unit-cell>"
  val supertype = Some(DatumCell)
  val directSubtypes = Set[CellType]()

  val typeId = 1L

  val typeIdGepIndices = List(0, 0, 0)
  val gcStateGepIndices = List(0, 0, 1)

  val typeIdTbaaIndex = 12L
  val gcStateTbaaIndex = 13L
}

sealed trait ListElementFields extends DatumFields {
  val irType : FirstClassType
}

object ListElementCell extends CellType with ListElementFields {
  val llvmName = "listElement"
  val irType = UserDefinedType("listElement")
  val schemeName = "<list-element-cell>"
  val supertype = Some(DatumCell)
  val directSubtypes = Set[CellType](PairCell, EmptyListCell)

  val typeIdGepIndices = List(0, 0, 0)
  val gcStateGepIndices = List(0, 0, 1)

  val typeIdTbaaIndex = 14L
  val gcStateTbaaIndex = 15L

  def createConstant(typeId : Long) : StructureConstant = {
    StructureConstant(List(
      DatumCell.createConstant(typeId=typeId)
    ), userDefinedType=Some(irType))
  }
}

sealed trait PairFields extends ListElementFields {
  val irType : FirstClassType

  val carIrType = PointerType(UserDefinedType("datum"))
  val carTbaaIndex : Long
  val carGepIndices : List[Int]

  val cdrIrType = PointerType(UserDefinedType("datum"))
  val cdrTbaaIndex : Long
  val cdrGepIndices : List[Int]

  def genPointerToCar(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("carPtr")(
      elementType=carIrType,
      basePointer=valueCell,
      indices=carGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToCar(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val carPtr = genPointerToCar(block)(valueCell)
    block.store(toStore, carPtr, tbaaIndex=Some(carTbaaIndex))
  }

  def genLoadFromCar(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val carPtr = genPointerToCar(block)(valueCell)
    block.load("car")(carPtr, tbaaIndex=Some(carTbaaIndex))
  }

  def genPointerToCdr(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("cdrPtr")(
      elementType=cdrIrType,
      basePointer=valueCell,
      indices=cdrGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToCdr(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val cdrPtr = genPointerToCdr(block)(valueCell)
    block.store(toStore, cdrPtr, tbaaIndex=Some(cdrTbaaIndex))
  }

  def genLoadFromCdr(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val cdrPtr = genPointerToCdr(block)(valueCell)
    block.load("cdr")(cdrPtr, tbaaIndex=Some(cdrTbaaIndex))
  }
}

object PairCell extends ConcreteCellType with PairFields {
  val llvmName = "pair"
  val irType = UserDefinedType("pair")
  val schemeName = "<pair-cell>"
  val supertype = Some(ListElementCell)
  val directSubtypes = Set[CellType]()

  val typeId = 2L

  val typeIdGepIndices = List(0, 0, 0, 0)
  val gcStateGepIndices = List(0, 0, 0, 1)
  val carGepIndices = List(0, 1)
  val cdrGepIndices = List(0, 2)

  val typeIdTbaaIndex = 16L
  val gcStateTbaaIndex = 17L
  val carTbaaIndex = 18L
  val cdrTbaaIndex = 19L

  def createConstant(car : IrConstant, cdr : IrConstant) : StructureConstant = {
    if (car.irType != carIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field car")
    }

    if (cdr.irType != cdrIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field cdr")
    }

    StructureConstant(List(
      ListElementCell.createConstant(typeId=typeId),
      car,
      cdr
    ), userDefinedType=Some(irType))
  }
}

sealed trait EmptyListFields extends ListElementFields {
  val irType : FirstClassType
}

object EmptyListCell extends ConcreteCellType with EmptyListFields {
  val llvmName = "emptyList"
  val irType = UserDefinedType("emptyList")
  val schemeName = "<empty-list-cell>"
  val supertype = Some(ListElementCell)
  val directSubtypes = Set[CellType]()

  val typeId = 3L

  val typeIdGepIndices = List(0, 0, 0, 0)
  val gcStateGepIndices = List(0, 0, 0, 1)

  val typeIdTbaaIndex = 20L
  val gcStateTbaaIndex = 21L
}

sealed trait StringFields extends DatumFields {
  val irType : FirstClassType

  val allocSlackBytesIrType = IntegerType(16)
  val allocSlackBytesTbaaIndex : Long
  val allocSlackBytesGepIndices : List[Int]

  val charLengthIrType = IntegerType(32)
  val charLengthTbaaIndex : Long
  val charLengthGepIndices : List[Int]

  val byteLengthIrType = IntegerType(32)
  val byteLengthTbaaIndex : Long
  val byteLengthGepIndices : List[Int]

  def genPointerToAllocSlackBytes(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("allocSlackBytesPtr")(
      elementType=allocSlackBytesIrType,
      basePointer=valueCell,
      indices=allocSlackBytesGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToAllocSlackBytes(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val allocSlackBytesPtr = genPointerToAllocSlackBytes(block)(valueCell)
    block.store(toStore, allocSlackBytesPtr, tbaaIndex=Some(allocSlackBytesTbaaIndex))
  }

  def genLoadFromAllocSlackBytes(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val allocSlackBytesPtr = genPointerToAllocSlackBytes(block)(valueCell)
    block.load("allocSlackBytes")(allocSlackBytesPtr, tbaaIndex=Some(allocSlackBytesTbaaIndex))
  }

  def genPointerToCharLength(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("charLengthPtr")(
      elementType=charLengthIrType,
      basePointer=valueCell,
      indices=charLengthGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToCharLength(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val charLengthPtr = genPointerToCharLength(block)(valueCell)
    block.store(toStore, charLengthPtr, tbaaIndex=Some(charLengthTbaaIndex))
  }

  def genLoadFromCharLength(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val charLengthPtr = genPointerToCharLength(block)(valueCell)
    block.load("charLength")(charLengthPtr, tbaaIndex=Some(charLengthTbaaIndex))
  }

  def genPointerToByteLength(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("byteLengthPtr")(
      elementType=byteLengthIrType,
      basePointer=valueCell,
      indices=byteLengthGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToByteLength(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val byteLengthPtr = genPointerToByteLength(block)(valueCell)
    block.store(toStore, byteLengthPtr, tbaaIndex=Some(byteLengthTbaaIndex))
  }

  def genLoadFromByteLength(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val byteLengthPtr = genPointerToByteLength(block)(valueCell)
    block.load("byteLength")(byteLengthPtr, tbaaIndex=Some(byteLengthTbaaIndex))
  }
}

object StringCell extends ConcreteCellType with StringFields {
  val llvmName = "string"
  val irType = UserDefinedType("string")
  val schemeName = "<string-cell>"
  val supertype = Some(DatumCell)
  val directSubtypes = Set[CellType]()

  val typeId = 4L

  val typeIdGepIndices = List(0, 0, 0)
  val gcStateGepIndices = List(0, 0, 1)
  val allocSlackBytesGepIndices = List(0, 1)
  val charLengthGepIndices = List(0, 2)
  val byteLengthGepIndices = List(0, 3)

  val typeIdTbaaIndex = 22L
  val gcStateTbaaIndex = 23L
  val allocSlackBytesTbaaIndex = 24L
  val charLengthTbaaIndex = 25L
  val byteLengthTbaaIndex = 26L

  def createConstant(allocSlackBytes : Long, charLength : Long, byteLength : Long) : StructureConstant = {
    StructureConstant(List(
      DatumCell.createConstant(typeId=typeId),
      IntegerConstant(allocSlackBytesIrType, allocSlackBytes),
      IntegerConstant(charLengthIrType, charLength),
      IntegerConstant(byteLengthIrType, byteLength)
    ), userDefinedType=Some(irType))
  }
}

sealed trait InlineStringFields extends StringFields {
  val irType : FirstClassType

  val inlineDataIrType = ArrayType(12, IntegerType(8))
  val inlineDataTbaaIndex : Long
  val inlineDataGepIndices : List[Int]

  def genPointerToInlineData(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("inlineDataPtr")(
      elementType=inlineDataIrType,
      basePointer=valueCell,
      indices=inlineDataGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToInlineData(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val inlineDataPtr = genPointerToInlineData(block)(valueCell)
    block.store(toStore, inlineDataPtr, tbaaIndex=Some(inlineDataTbaaIndex))
  }

  def genLoadFromInlineData(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val inlineDataPtr = genPointerToInlineData(block)(valueCell)
    block.load("inlineData")(inlineDataPtr, tbaaIndex=Some(inlineDataTbaaIndex))
  }
}

object InlineStringCell extends CellTypeVariant with InlineStringFields {
  val llvmName = "inlineString"
  val irType = UserDefinedType("inlineString")

  val typeIdGepIndices = List(0, 0, 0, 0)
  val gcStateGepIndices = List(0, 0, 0, 1)
  val allocSlackBytesGepIndices = List(0, 0, 1)
  val charLengthGepIndices = List(0, 0, 2)
  val byteLengthGepIndices = List(0, 0, 3)
  val inlineDataGepIndices = List(0, 1)

  val inlineDataTbaaIndex = 27L
  val typeIdTbaaIndex = 22L
  val gcStateTbaaIndex = 23L
  val allocSlackBytesTbaaIndex = 24L
  val charLengthTbaaIndex = 25L
  val byteLengthTbaaIndex = 26L

  def createConstant(inlineData : IrConstant, allocSlackBytes : Long, charLength : Long, byteLength : Long) : StructureConstant = {
    if (inlineData.irType != inlineDataIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field inlineData")
    }

    StructureConstant(List(
      StringCell.createConstant(allocSlackBytes=allocSlackBytes, charLength=charLength, byteLength=byteLength),
      inlineData
    ), userDefinedType=Some(irType))
  }
}

sealed trait HeapStringFields extends StringFields {
  val irType : FirstClassType

  val heapDataIrType = PointerType(IntegerType(8))
  val heapDataTbaaIndex : Long
  val heapDataGepIndices : List[Int]

  def genPointerToHeapData(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("heapDataPtr")(
      elementType=heapDataIrType,
      basePointer=valueCell,
      indices=heapDataGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToHeapData(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val heapDataPtr = genPointerToHeapData(block)(valueCell)
    block.store(toStore, heapDataPtr, tbaaIndex=Some(heapDataTbaaIndex))
  }

  def genLoadFromHeapData(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val heapDataPtr = genPointerToHeapData(block)(valueCell)
    block.load("heapData")(heapDataPtr, tbaaIndex=Some(heapDataTbaaIndex))
  }
}

object HeapStringCell extends CellTypeVariant with HeapStringFields {
  val llvmName = "heapString"
  val irType = UserDefinedType("heapString")

  val typeIdGepIndices = List(0, 0, 0, 0)
  val gcStateGepIndices = List(0, 0, 0, 1)
  val allocSlackBytesGepIndices = List(0, 0, 1)
  val charLengthGepIndices = List(0, 0, 2)
  val byteLengthGepIndices = List(0, 0, 3)
  val heapDataGepIndices = List(0, 1)

  val heapDataTbaaIndex = 28L
  val typeIdTbaaIndex = 22L
  val gcStateTbaaIndex = 23L
  val allocSlackBytesTbaaIndex = 24L
  val charLengthTbaaIndex = 25L
  val byteLengthTbaaIndex = 26L

  def createConstant(heapData : IrConstant, allocSlackBytes : Long, charLength : Long, byteLength : Long) : StructureConstant = {
    if (heapData.irType != heapDataIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field heapData")
    }

    StructureConstant(List(
      StringCell.createConstant(allocSlackBytes=allocSlackBytes, charLength=charLength, byteLength=byteLength),
      heapData
    ), userDefinedType=Some(irType))
  }
}

sealed trait SymbolFields extends DatumFields {
  val irType : FirstClassType

  val charLengthIrType = IntegerType(32)
  val charLengthTbaaIndex : Long
  val charLengthGepIndices : List[Int]

  val byteLengthIrType = IntegerType(32)
  val byteLengthTbaaIndex : Long
  val byteLengthGepIndices : List[Int]

  def genPointerToCharLength(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("charLengthPtr")(
      elementType=charLengthIrType,
      basePointer=valueCell,
      indices=charLengthGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToCharLength(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val charLengthPtr = genPointerToCharLength(block)(valueCell)
    block.store(toStore, charLengthPtr, tbaaIndex=Some(charLengthTbaaIndex))
  }

  def genLoadFromCharLength(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val charLengthPtr = genPointerToCharLength(block)(valueCell)
    block.load("charLength")(charLengthPtr, tbaaIndex=Some(charLengthTbaaIndex))
  }

  def genPointerToByteLength(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("byteLengthPtr")(
      elementType=byteLengthIrType,
      basePointer=valueCell,
      indices=byteLengthGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToByteLength(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val byteLengthPtr = genPointerToByteLength(block)(valueCell)
    block.store(toStore, byteLengthPtr, tbaaIndex=Some(byteLengthTbaaIndex))
  }

  def genLoadFromByteLength(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val byteLengthPtr = genPointerToByteLength(block)(valueCell)
    block.load("byteLength")(byteLengthPtr, tbaaIndex=Some(byteLengthTbaaIndex))
  }
}

object SymbolCell extends ConcreteCellType with SymbolFields {
  val llvmName = "symbol"
  val irType = UserDefinedType("symbol")
  val schemeName = "<symbol-cell>"
  val supertype = Some(DatumCell)
  val directSubtypes = Set[CellType]()

  val typeId = 5L

  val typeIdGepIndices = List(0, 0, 0)
  val gcStateGepIndices = List(0, 0, 1)
  val charLengthGepIndices = List(0, 1)
  val byteLengthGepIndices = List(0, 2)

  val typeIdTbaaIndex = 29L
  val gcStateTbaaIndex = 30L
  val charLengthTbaaIndex = 31L
  val byteLengthTbaaIndex = 32L

  def createConstant(charLength : Long, byteLength : Long) : StructureConstant = {
    StructureConstant(List(
      DatumCell.createConstant(typeId=typeId),
      IntegerConstant(charLengthIrType, charLength),
      IntegerConstant(byteLengthIrType, byteLength)
    ), userDefinedType=Some(irType))
  }
}

sealed trait InlineSymbolFields extends SymbolFields {
  val irType : FirstClassType

  val inlineDataIrType = ArrayType(12, IntegerType(8))
  val inlineDataTbaaIndex : Long
  val inlineDataGepIndices : List[Int]

  def genPointerToInlineData(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("inlineDataPtr")(
      elementType=inlineDataIrType,
      basePointer=valueCell,
      indices=inlineDataGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToInlineData(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val inlineDataPtr = genPointerToInlineData(block)(valueCell)
    block.store(toStore, inlineDataPtr, tbaaIndex=Some(inlineDataTbaaIndex))
  }

  def genLoadFromInlineData(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val inlineDataPtr = genPointerToInlineData(block)(valueCell)
    block.load("inlineData")(inlineDataPtr, tbaaIndex=Some(inlineDataTbaaIndex))
  }
}

object InlineSymbolCell extends CellTypeVariant with InlineSymbolFields {
  val llvmName = "inlineSymbol"
  val irType = UserDefinedType("inlineSymbol")

  val typeIdGepIndices = List(0, 0, 0, 0)
  val gcStateGepIndices = List(0, 0, 0, 1)
  val charLengthGepIndices = List(0, 0, 1)
  val byteLengthGepIndices = List(0, 0, 2)
  val inlineDataGepIndices = List(0, 1)

  val inlineDataTbaaIndex = 33L
  val typeIdTbaaIndex = 29L
  val gcStateTbaaIndex = 30L
  val charLengthTbaaIndex = 31L
  val byteLengthTbaaIndex = 32L

  def createConstant(inlineData : IrConstant, charLength : Long, byteLength : Long) : StructureConstant = {
    if (inlineData.irType != inlineDataIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field inlineData")
    }

    StructureConstant(List(
      SymbolCell.createConstant(charLength=charLength, byteLength=byteLength),
      inlineData
    ), userDefinedType=Some(irType))
  }
}

sealed trait HeapSymbolFields extends SymbolFields {
  val irType : FirstClassType

  val heapDataIrType = PointerType(IntegerType(8))
  val heapDataTbaaIndex : Long
  val heapDataGepIndices : List[Int]

  def genPointerToHeapData(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("heapDataPtr")(
      elementType=heapDataIrType,
      basePointer=valueCell,
      indices=heapDataGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToHeapData(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val heapDataPtr = genPointerToHeapData(block)(valueCell)
    block.store(toStore, heapDataPtr, tbaaIndex=Some(heapDataTbaaIndex))
  }

  def genLoadFromHeapData(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val heapDataPtr = genPointerToHeapData(block)(valueCell)
    block.load("heapData")(heapDataPtr, tbaaIndex=Some(heapDataTbaaIndex))
  }
}

object HeapSymbolCell extends CellTypeVariant with HeapSymbolFields {
  val llvmName = "heapSymbol"
  val irType = UserDefinedType("heapSymbol")

  val typeIdGepIndices = List(0, 0, 0, 0)
  val gcStateGepIndices = List(0, 0, 0, 1)
  val charLengthGepIndices = List(0, 0, 1)
  val byteLengthGepIndices = List(0, 0, 2)
  val heapDataGepIndices = List(0, 1)

  val heapDataTbaaIndex = 34L
  val typeIdTbaaIndex = 29L
  val gcStateTbaaIndex = 30L
  val charLengthTbaaIndex = 31L
  val byteLengthTbaaIndex = 32L

  def createConstant(heapData : IrConstant, charLength : Long, byteLength : Long) : StructureConstant = {
    if (heapData.irType != heapDataIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field heapData")
    }

    StructureConstant(List(
      SymbolCell.createConstant(charLength=charLength, byteLength=byteLength),
      heapData
    ), userDefinedType=Some(irType))
  }
}

sealed trait BooleanFields extends DatumFields {
  val irType : FirstClassType

  val valueIrType = IntegerType(8)
  val valueTbaaIndex : Long
  val valueGepIndices : List[Int]

  def genPointerToValue(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("valuePtr")(
      elementType=valueIrType,
      basePointer=valueCell,
      indices=valueGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToValue(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val valuePtr = genPointerToValue(block)(valueCell)
    block.store(toStore, valuePtr, tbaaIndex=Some(valueTbaaIndex))
  }

  def genLoadFromValue(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val valuePtr = genPointerToValue(block)(valueCell)
    block.load("value")(valuePtr, tbaaIndex=Some(valueTbaaIndex))
  }
}

object BooleanCell extends ConcreteCellType with BooleanFields {
  val llvmName = "boolean"
  val irType = UserDefinedType("boolean")
  val schemeName = "<boolean-cell>"
  val supertype = Some(DatumCell)
  val directSubtypes = Set[CellType]()

  val typeId = 6L

  val typeIdGepIndices = List(0, 0, 0)
  val gcStateGepIndices = List(0, 0, 1)
  val valueGepIndices = List(0, 1)

  val typeIdTbaaIndex = 35L
  val gcStateTbaaIndex = 36L
  val valueTbaaIndex = 37L
}

sealed trait NumericFields extends DatumFields {
  val irType : FirstClassType
}

object NumericCell extends CellType with NumericFields {
  val llvmName = "numeric"
  val irType = UserDefinedType("numeric")
  val schemeName = "<numeric-cell>"
  val supertype = Some(DatumCell)
  val directSubtypes = Set[CellType](ExactIntegerCell, InexactRationalCell)

  val typeIdGepIndices = List(0, 0, 0)
  val gcStateGepIndices = List(0, 0, 1)

  val typeIdTbaaIndex = 38L
  val gcStateTbaaIndex = 39L

  def createConstant(typeId : Long) : StructureConstant = {
    StructureConstant(List(
      DatumCell.createConstant(typeId=typeId)
    ), userDefinedType=Some(irType))
  }
}

sealed trait ExactIntegerFields extends NumericFields {
  val irType : FirstClassType

  val valueIrType = IntegerType(64)
  val valueTbaaIndex : Long
  val valueGepIndices : List[Int]

  def genPointerToValue(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("valuePtr")(
      elementType=valueIrType,
      basePointer=valueCell,
      indices=valueGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToValue(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val valuePtr = genPointerToValue(block)(valueCell)
    block.store(toStore, valuePtr, tbaaIndex=Some(valueTbaaIndex))
  }

  def genLoadFromValue(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val valuePtr = genPointerToValue(block)(valueCell)
    block.load("value")(valuePtr, tbaaIndex=Some(valueTbaaIndex))
  }
}

object ExactIntegerCell extends ConcreteCellType with ExactIntegerFields {
  val llvmName = "exactInteger"
  val irType = UserDefinedType("exactInteger")
  val schemeName = "<exact-integer-cell>"
  val supertype = Some(NumericCell)
  val directSubtypes = Set[CellType]()

  val typeId = 7L

  val typeIdGepIndices = List(0, 0, 0, 0)
  val gcStateGepIndices = List(0, 0, 0, 1)
  val valueGepIndices = List(0, 1)

  val typeIdTbaaIndex = 40L
  val gcStateTbaaIndex = 41L
  val valueTbaaIndex = 42L

  def createConstant(value : Long) : StructureConstant = {
    StructureConstant(List(
      NumericCell.createConstant(typeId=typeId),
      IntegerConstant(valueIrType, value)
    ), userDefinedType=Some(irType))
  }
}

sealed trait InexactRationalFields extends NumericFields {
  val irType : FirstClassType

  val valueIrType = DoubleType
  val valueTbaaIndex : Long
  val valueGepIndices : List[Int]

  def genPointerToValue(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("valuePtr")(
      elementType=valueIrType,
      basePointer=valueCell,
      indices=valueGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToValue(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val valuePtr = genPointerToValue(block)(valueCell)
    block.store(toStore, valuePtr, tbaaIndex=Some(valueTbaaIndex))
  }

  def genLoadFromValue(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val valuePtr = genPointerToValue(block)(valueCell)
    block.load("value")(valuePtr, tbaaIndex=Some(valueTbaaIndex))
  }
}

object InexactRationalCell extends ConcreteCellType with InexactRationalFields {
  val llvmName = "inexactRational"
  val irType = UserDefinedType("inexactRational")
  val schemeName = "<inexact-rational-cell>"
  val supertype = Some(NumericCell)
  val directSubtypes = Set[CellType]()

  val typeId = 8L

  val typeIdGepIndices = List(0, 0, 0, 0)
  val gcStateGepIndices = List(0, 0, 0, 1)
  val valueGepIndices = List(0, 1)

  val typeIdTbaaIndex = 43L
  val gcStateTbaaIndex = 44L
  val valueTbaaIndex = 45L

  def createConstant(value : IrConstant) : StructureConstant = {
    if (value.irType != valueIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field value")
    }

    StructureConstant(List(
      NumericCell.createConstant(typeId=typeId),
      value
    ), userDefinedType=Some(irType))
  }
}

sealed trait CharacterFields extends DatumFields {
  val irType : FirstClassType

  val unicodeCharIrType = IntegerType(32)
  val unicodeCharTbaaIndex : Long
  val unicodeCharGepIndices : List[Int]

  def genPointerToUnicodeChar(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("unicodeCharPtr")(
      elementType=unicodeCharIrType,
      basePointer=valueCell,
      indices=unicodeCharGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToUnicodeChar(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val unicodeCharPtr = genPointerToUnicodeChar(block)(valueCell)
    block.store(toStore, unicodeCharPtr, tbaaIndex=Some(unicodeCharTbaaIndex))
  }

  def genLoadFromUnicodeChar(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val unicodeCharPtr = genPointerToUnicodeChar(block)(valueCell)
    block.load("unicodeChar")(unicodeCharPtr, tbaaIndex=Some(unicodeCharTbaaIndex))
  }
}

object CharacterCell extends ConcreteCellType with CharacterFields {
  val llvmName = "character"
  val irType = UserDefinedType("character")
  val schemeName = "<character-cell>"
  val supertype = Some(DatumCell)
  val directSubtypes = Set[CellType]()

  val typeId = 9L

  val typeIdGepIndices = List(0, 0, 0)
  val gcStateGepIndices = List(0, 0, 1)
  val unicodeCharGepIndices = List(0, 1)

  val typeIdTbaaIndex = 46L
  val gcStateTbaaIndex = 47L
  val unicodeCharTbaaIndex = 48L

  def createConstant(unicodeChar : Long) : StructureConstant = {
    StructureConstant(List(
      DatumCell.createConstant(typeId=typeId),
      IntegerConstant(unicodeCharIrType, unicodeChar)
    ), userDefinedType=Some(irType))
  }
}

sealed trait VectorFields extends DatumFields {
  val irType : FirstClassType

  val lengthIrType = IntegerType(32)
  val lengthTbaaIndex : Long
  val lengthGepIndices : List[Int]

  val elementsIrType = PointerType(PointerType(UserDefinedType("datum")))
  val elementsTbaaIndex : Long
  val elementsGepIndices : List[Int]

  def genPointerToLength(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("lengthPtr")(
      elementType=lengthIrType,
      basePointer=valueCell,
      indices=lengthGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToLength(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val lengthPtr = genPointerToLength(block)(valueCell)
    block.store(toStore, lengthPtr, tbaaIndex=Some(lengthTbaaIndex))
  }

  def genLoadFromLength(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val lengthPtr = genPointerToLength(block)(valueCell)
    block.load("length")(lengthPtr, tbaaIndex=Some(lengthTbaaIndex))
  }

  def genPointerToElements(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("elementsPtr")(
      elementType=elementsIrType,
      basePointer=valueCell,
      indices=elementsGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToElements(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val elementsPtr = genPointerToElements(block)(valueCell)
    block.store(toStore, elementsPtr, tbaaIndex=Some(elementsTbaaIndex))
  }

  def genLoadFromElements(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val elementsPtr = genPointerToElements(block)(valueCell)
    block.load("elements")(elementsPtr, tbaaIndex=Some(elementsTbaaIndex))
  }
}

object VectorCell extends ConcreteCellType with VectorFields {
  val llvmName = "vector"
  val irType = UserDefinedType("vector")
  val schemeName = "<vector-cell>"
  val supertype = Some(DatumCell)
  val directSubtypes = Set[CellType]()

  val typeId = 10L

  val typeIdGepIndices = List(0, 0, 0)
  val gcStateGepIndices = List(0, 0, 1)
  val lengthGepIndices = List(0, 1)
  val elementsGepIndices = List(0, 2)

  val typeIdTbaaIndex = 49L
  val gcStateTbaaIndex = 50L
  val lengthTbaaIndex = 51L
  val elementsTbaaIndex = 52L

  def createConstant(length : Long, elements : IrConstant) : StructureConstant = {
    if (elements.irType != elementsIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field elements")
    }

    StructureConstant(List(
      DatumCell.createConstant(typeId=typeId),
      IntegerConstant(lengthIrType, length),
      elements
    ), userDefinedType=Some(irType))
  }
}

sealed trait BytevectorFields extends DatumFields {
  val irType : FirstClassType

  val lengthIrType = IntegerType(32)
  val lengthTbaaIndex : Long
  val lengthGepIndices : List[Int]

  val dataIrType = PointerType(IntegerType(8))
  val dataTbaaIndex : Long
  val dataGepIndices : List[Int]

  def genPointerToLength(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("lengthPtr")(
      elementType=lengthIrType,
      basePointer=valueCell,
      indices=lengthGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToLength(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val lengthPtr = genPointerToLength(block)(valueCell)
    block.store(toStore, lengthPtr, tbaaIndex=Some(lengthTbaaIndex))
  }

  def genLoadFromLength(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val lengthPtr = genPointerToLength(block)(valueCell)
    block.load("length")(lengthPtr, tbaaIndex=Some(lengthTbaaIndex))
  }

  def genPointerToData(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("dataPtr")(
      elementType=dataIrType,
      basePointer=valueCell,
      indices=dataGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToData(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val dataPtr = genPointerToData(block)(valueCell)
    block.store(toStore, dataPtr, tbaaIndex=Some(dataTbaaIndex))
  }

  def genLoadFromData(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val dataPtr = genPointerToData(block)(valueCell)
    block.load("data")(dataPtr, tbaaIndex=Some(dataTbaaIndex))
  }
}

object BytevectorCell extends ConcreteCellType with BytevectorFields {
  val llvmName = "bytevector"
  val irType = UserDefinedType("bytevector")
  val schemeName = "<bytevector-cell>"
  val supertype = Some(DatumCell)
  val directSubtypes = Set[CellType]()

  val typeId = 11L

  val typeIdGepIndices = List(0, 0, 0)
  val gcStateGepIndices = List(0, 0, 1)
  val lengthGepIndices = List(0, 1)
  val dataGepIndices = List(0, 2)

  val typeIdTbaaIndex = 53L
  val gcStateTbaaIndex = 54L
  val lengthTbaaIndex = 55L
  val dataTbaaIndex = 56L

  def createConstant(length : Long, data : IrConstant) : StructureConstant = {
    if (data.irType != dataIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field data")
    }

    StructureConstant(List(
      DatumCell.createConstant(typeId=typeId),
      IntegerConstant(lengthIrType, length),
      data
    ), userDefinedType=Some(irType))
  }
}

sealed trait RecordLikeFields extends DatumFields {
  val irType : FirstClassType

  val dataIsInlineIrType = IntegerType(8)
  val dataIsInlineTbaaIndex : Long
  val dataIsInlineGepIndices : List[Int]

  val recordClassIdIrType = IntegerType(32)
  val recordClassIdTbaaIndex : Long
  val recordClassIdGepIndices : List[Int]

  val recordDataIrType = PointerType(IntegerType(8))
  val recordDataTbaaIndex : Long
  val recordDataGepIndices : List[Int]

  def genPointerToDataIsInline(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("dataIsInlinePtr")(
      elementType=dataIsInlineIrType,
      basePointer=valueCell,
      indices=dataIsInlineGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToDataIsInline(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val dataIsInlinePtr = genPointerToDataIsInline(block)(valueCell)
    block.store(toStore, dataIsInlinePtr, tbaaIndex=Some(dataIsInlineTbaaIndex))
  }

  def genLoadFromDataIsInline(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val dataIsInlinePtr = genPointerToDataIsInline(block)(valueCell)
    block.load("dataIsInline")(dataIsInlinePtr, tbaaIndex=Some(dataIsInlineTbaaIndex))
  }

  def genPointerToRecordClassId(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("recordClassIdPtr")(
      elementType=recordClassIdIrType,
      basePointer=valueCell,
      indices=recordClassIdGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToRecordClassId(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val recordClassIdPtr = genPointerToRecordClassId(block)(valueCell)
    block.store(toStore, recordClassIdPtr, tbaaIndex=Some(recordClassIdTbaaIndex))
  }

  def genLoadFromRecordClassId(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val recordClassIdPtr = genPointerToRecordClassId(block)(valueCell)
    block.load("recordClassId")(recordClassIdPtr, tbaaIndex=Some(recordClassIdTbaaIndex))
  }

  def genPointerToRecordData(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("recordDataPtr")(
      elementType=recordDataIrType,
      basePointer=valueCell,
      indices=recordDataGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToRecordData(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val recordDataPtr = genPointerToRecordData(block)(valueCell)
    block.store(toStore, recordDataPtr, tbaaIndex=Some(recordDataTbaaIndex))
  }

  def genLoadFromRecordData(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val recordDataPtr = genPointerToRecordData(block)(valueCell)
    block.load("recordData")(recordDataPtr, tbaaIndex=Some(recordDataTbaaIndex))
  }
}

object RecordLikeCell extends CellType with RecordLikeFields {
  val llvmName = "recordLike"
  val irType = UserDefinedType("recordLike")
  val schemeName = "<record-like-cell>"
  val supertype = Some(DatumCell)
  val directSubtypes = Set[CellType](ProcedureCell, RecordCell)

  val typeIdGepIndices = List(0, 0, 0)
  val gcStateGepIndices = List(0, 0, 1)
  val dataIsInlineGepIndices = List(0, 1)
  val recordClassIdGepIndices = List(0, 2)
  val recordDataGepIndices = List(0, 3)

  val typeIdTbaaIndex = 57L
  val gcStateTbaaIndex = 58L
  val dataIsInlineTbaaIndex = 59L
  val recordClassIdTbaaIndex = 60L
  val recordDataTbaaIndex = 61L

  def createConstant(dataIsInline : Long, recordClassId : Long, recordData : IrConstant, typeId : Long) : StructureConstant = {
    if (recordData.irType != recordDataIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field recordData")
    }

    StructureConstant(List(
      DatumCell.createConstant(typeId=typeId),
      IntegerConstant(dataIsInlineIrType, dataIsInline),
      IntegerConstant(recordClassIdIrType, recordClassId),
      recordData
    ), userDefinedType=Some(irType))
  }
}

sealed trait ProcedureFields extends RecordLikeFields {
  val irType : FirstClassType

  val entryPointIrType = PointerType(FunctionType(PointerType(UserDefinedType("datum")), List(PointerType(UserDefinedType("world")), PointerType(UserDefinedType("procedure")), PointerType(UserDefinedType("listElement")))))
  val entryPointTbaaIndex : Long
  val entryPointGepIndices : List[Int]

  def genPointerToEntryPoint(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("entryPointPtr")(
      elementType=entryPointIrType,
      basePointer=valueCell,
      indices=entryPointGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToEntryPoint(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val entryPointPtr = genPointerToEntryPoint(block)(valueCell)
    block.store(toStore, entryPointPtr, tbaaIndex=Some(entryPointTbaaIndex))
  }

  def genLoadFromEntryPoint(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val entryPointPtr = genPointerToEntryPoint(block)(valueCell)
    block.load("entryPoint")(entryPointPtr, tbaaIndex=Some(entryPointTbaaIndex))
  }
}

object ProcedureCell extends ConcreteCellType with ProcedureFields {
  val llvmName = "procedure"
  val irType = UserDefinedType("procedure")
  val schemeName = "<procedure-cell>"
  val supertype = Some(RecordLikeCell)
  val directSubtypes = Set[CellType]()

  val typeId = 12L

  val typeIdGepIndices = List(0, 0, 0, 0)
  val gcStateGepIndices = List(0, 0, 0, 1)
  val dataIsInlineGepIndices = List(0, 0, 1)
  val recordClassIdGepIndices = List(0, 0, 2)
  val recordDataGepIndices = List(0, 0, 3)
  val entryPointGepIndices = List(0, 1)

  val typeIdTbaaIndex = 62L
  val gcStateTbaaIndex = 63L
  val dataIsInlineTbaaIndex = 64L
  val recordClassIdTbaaIndex = 65L
  val recordDataTbaaIndex = 66L
  val entryPointTbaaIndex = 67L

  def createConstant(entryPoint : IrConstant, dataIsInline : Long, recordClassId : Long, recordData : IrConstant) : StructureConstant = {
    if (entryPoint.irType != entryPointIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field entryPoint")
    }

    StructureConstant(List(
      RecordLikeCell.createConstant(dataIsInline=dataIsInline, recordClassId=recordClassId, recordData=recordData, typeId=typeId),
      entryPoint
    ), userDefinedType=Some(irType))
  }
}

sealed trait RecordFields extends RecordLikeFields {
  val irType : FirstClassType

  val extraDataIrType = PointerType(IntegerType(8))
  val extraDataTbaaIndex : Long
  val extraDataGepIndices : List[Int]

  def genPointerToExtraData(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("extraDataPtr")(
      elementType=extraDataIrType,
      basePointer=valueCell,
      indices=extraDataGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToExtraData(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val extraDataPtr = genPointerToExtraData(block)(valueCell)
    block.store(toStore, extraDataPtr, tbaaIndex=Some(extraDataTbaaIndex))
  }

  def genLoadFromExtraData(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val extraDataPtr = genPointerToExtraData(block)(valueCell)
    block.load("extraData")(extraDataPtr, tbaaIndex=Some(extraDataTbaaIndex))
  }
}

object RecordCell extends ConcreteCellType with RecordFields {
  val llvmName = "record"
  val irType = UserDefinedType("record")
  val schemeName = "<record-cell>"
  val supertype = Some(RecordLikeCell)
  val directSubtypes = Set[CellType]()

  val typeId = 13L

  val typeIdGepIndices = List(0, 0, 0, 0)
  val gcStateGepIndices = List(0, 0, 0, 1)
  val dataIsInlineGepIndices = List(0, 0, 1)
  val recordClassIdGepIndices = List(0, 0, 2)
  val recordDataGepIndices = List(0, 0, 3)
  val extraDataGepIndices = List(0, 1)

  val typeIdTbaaIndex = 68L
  val gcStateTbaaIndex = 69L
  val dataIsInlineTbaaIndex = 70L
  val recordClassIdTbaaIndex = 71L
  val recordDataTbaaIndex = 72L
  val extraDataTbaaIndex = 73L

  def createConstant(extraData : IrConstant, dataIsInline : Long, recordClassId : Long, recordData : IrConstant) : StructureConstant = {
    if (extraData.irType != extraDataIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field extraData")
    }

    StructureConstant(List(
      RecordLikeCell.createConstant(dataIsInline=dataIsInline, recordClassId=recordClassId, recordData=recordData, typeId=typeId),
      extraData
    ), userDefinedType=Some(irType))
  }
}

sealed trait ErrorObjectFields extends DatumFields {
  val irType : FirstClassType

  val messageIrType = PointerType(UserDefinedType("string"))
  val messageTbaaIndex : Long
  val messageGepIndices : List[Int]

  val irritantsIrType = PointerType(UserDefinedType("listElement"))
  val irritantsTbaaIndex : Long
  val irritantsGepIndices : List[Int]

  def genPointerToMessage(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("messagePtr")(
      elementType=messageIrType,
      basePointer=valueCell,
      indices=messageGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToMessage(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val messagePtr = genPointerToMessage(block)(valueCell)
    block.store(toStore, messagePtr, tbaaIndex=Some(messageTbaaIndex))
  }

  def genLoadFromMessage(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val messagePtr = genPointerToMessage(block)(valueCell)
    block.load("message")(messagePtr, tbaaIndex=Some(messageTbaaIndex))
  }

  def genPointerToIrritants(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("irritantsPtr")(
      elementType=irritantsIrType,
      basePointer=valueCell,
      indices=irritantsGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToIrritants(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue)  {
    val irritantsPtr = genPointerToIrritants(block)(valueCell)
    block.store(toStore, irritantsPtr, tbaaIndex=Some(irritantsTbaaIndex))
  }

  def genLoadFromIrritants(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    val irritantsPtr = genPointerToIrritants(block)(valueCell)
    block.load("irritants")(irritantsPtr, tbaaIndex=Some(irritantsTbaaIndex))
  }
}

object ErrorObjectCell extends ConcreteCellType with ErrorObjectFields {
  val llvmName = "errorObject"
  val irType = UserDefinedType("errorObject")
  val schemeName = "<error-object-cell>"
  val supertype = Some(DatumCell)
  val directSubtypes = Set[CellType]()

  val typeId = 14L

  val typeIdGepIndices = List(0, 0, 0)
  val gcStateGepIndices = List(0, 0, 1)
  val messageGepIndices = List(0, 1)
  val irritantsGepIndices = List(0, 2)

  val typeIdTbaaIndex = 74L
  val gcStateTbaaIndex = 75L
  val messageTbaaIndex = 76L
  val irritantsTbaaIndex = 77L

  def createConstant(message : IrConstant, irritants : IrConstant) : StructureConstant = {
    if (message.irType != messageIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field message")
    }

    if (irritants.irType != irritantsIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field irritants")
    }

    StructureConstant(List(
      DatumCell.createConstant(typeId=typeId),
      message,
      irritants
    ), userDefinedType=Some(irType))
  }
}

