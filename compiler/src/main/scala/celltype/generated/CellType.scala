/************************************************************
 * This file is generated by typegen. Do not edit manually. *
 ************************************************************/

package io.llambda.compiler.celltype
import io.llambda

import llambda.llvmir._
import llambda.compiler.InternalCompilerErrorException

sealed abstract class CastableValue {
  val irType : FirstClassType
  val llvmName : String
  
  def genPointerBitcast(block : IrBlockBuilder)(uncastValue : IrValue) : IrValue =
    if (uncastValue.irType == PointerType(irType)) {
      uncastValue
    }
    else {
      block.bitcastTo(llvmName + "Cast")(uncastValue, PointerType(irType))
    }
}

sealed abstract class CellType extends CastableValue with DatumFields {
  val schemeName : String
  val directSubtypes : Set[CellType]

  def isTypeOrSubtypeOf(otherType : CellType) : Boolean = {
    otherType.isTypeOrSupertypeOf(this)
  }

  def isTypeOrSupertypeOf(otherType : CellType) : Boolean = {
    if (otherType == this) {
      return true
    }

    directSubtypes exists (_.isTypeOrSupertypeOf(otherType))
  }

  lazy val concreteTypes : Set[ConcreteCellType] = this match {
    case concreteType : ConcreteCellType => Set(concreteType)
    case abstractType => directSubtypes.flatMap(_.concreteTypes)
  }
}

sealed abstract class ConcreteCellType extends CellType {
  val typeId : Long
}

sealed abstract class PreconstructedCellType extends ConcreteCellType

sealed abstract class CellTypeVariant extends CastableValue

object CellType {
  val nextMetadataIndex = 87L
}

sealed trait DatumFields {
  val irType : FirstClassType

  val typeIdIrType = IntegerType(8)
  val typeIdTbaaNode : Metadata
  val typeIdGepIndices : List[Int]

  val gcStateIrType = IntegerType(8)
  val gcStateTbaaNode : Metadata
  val gcStateGepIndices : List[Int]

  def genPointerToTypeId(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("typeIdPtr")(
      elementType=typeIdIrType,
      basePointer=valueCell,
      indices=typeIdGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToTypeId(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue, metadata : Map[String, Metadata] = Map())  {
    val typeIdPtr = genPointerToTypeId(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> typeIdTbaaNode)
    block.store(toStore, typeIdPtr, metadata=allMetadata)
  }

  def genLoadFromTypeId(block : IrBlockBuilder)(valueCell : IrValue, metadata : Map[String, Metadata] = Map()) : IrValue = {
    val typeIdPtr = genPointerToTypeId(block)(valueCell)
    val allMetadata = Map("tbaa" -> typeIdTbaaNode) ++ metadata
    block.load("typeId")(typeIdPtr, metadata=allMetadata)
  }

  def genPointerToGcState(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("gcStatePtr")(
      elementType=gcStateIrType,
      basePointer=valueCell,
      indices=gcStateGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToGcState(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue, metadata : Map[String, Metadata] = Map())  {
    val gcStatePtr = genPointerToGcState(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> gcStateTbaaNode)
    block.store(toStore, gcStatePtr, metadata=allMetadata)
  }

  def genLoadFromGcState(block : IrBlockBuilder)(valueCell : IrValue, metadata : Map[String, Metadata] = Map()) : IrValue = {
    val gcStatePtr = genPointerToGcState(block)(valueCell)
    val allMetadata = Map("tbaa" -> gcStateTbaaNode) ++ metadata
    block.load("gcState")(gcStatePtr, metadata=allMetadata)
  }
}

object DatumCell extends CellType with DatumFields {
  val llvmName = "datum"
  val irType = UserDefinedType("datum")
  val schemeName = "<datum-cell>"
  val directSubtypes = Set[CellType](UnitCell, ListElementCell, StringCell, SymbolCell, BooleanCell, NumericCell, CharacterCell, VectorCell, BytevectorCell, RecordLikeCell, ErrorObjectCell, PortCell)

  val typeIdGepIndices = List(0, 0)
  val gcStateGepIndices = List(0, 1)

  val typeIdTbaaNode = NumberedMetadata(10L)
  val gcStateTbaaNode = NumberedMetadata(11L)

  def createConstant(typeId : Long) : StructureConstant = {
    StructureConstant(List(
      IntegerConstant(typeIdIrType, typeId),
      IntegerConstant(gcStateIrType, 1)
    ), userDefinedType=Some(irType))
  }
}

sealed trait UnitFields extends DatumFields {
  val irType : FirstClassType
}

object UnitCell extends PreconstructedCellType with UnitFields {
  val llvmName = "unit"
  val irType = UserDefinedType("unit")
  val schemeName = "<unit-cell>"
  val directSubtypes = Set[CellType]()

  val typeId = 1L

  val typeIdGepIndices = List(0, 0, 0)
  val gcStateGepIndices = List(0, 0, 1)

  val typeIdTbaaNode = NumberedMetadata(12L)
  val gcStateTbaaNode = NumberedMetadata(13L)
}

sealed trait ListElementFields extends DatumFields {
  val irType : FirstClassType
}

object ListElementCell extends CellType with ListElementFields {
  val llvmName = "listElement"
  val irType = UserDefinedType("listElement")
  val schemeName = "<list-element-cell>"
  val directSubtypes = Set[CellType](PairCell, EmptyListCell)

  val typeIdGepIndices = List(0, 0, 0)
  val gcStateGepIndices = List(0, 0, 1)

  val typeIdTbaaNode = NumberedMetadata(14L)
  val gcStateTbaaNode = NumberedMetadata(15L)

  def createConstant(typeId : Long) : StructureConstant = {
    StructureConstant(List(
      DatumCell.createConstant(typeId=typeId)
    ), userDefinedType=Some(irType))
  }
}

sealed trait PairFields extends ListElementFields {
  val irType : FirstClassType

  val memberTypeIdIrType = IntegerType(8)
  val memberTypeIdTbaaNode : Metadata
  val memberTypeIdGepIndices : List[Int]

  val listLengthIrType = IntegerType(32)
  val listLengthTbaaNode : Metadata
  val listLengthGepIndices : List[Int]

  val carIrType = PointerType(UserDefinedType("datum"))
  val carTbaaNode : Metadata
  val carGepIndices : List[Int]

  val cdrIrType = PointerType(UserDefinedType("datum"))
  val cdrTbaaNode : Metadata
  val cdrGepIndices : List[Int]

  def genPointerToMemberTypeId(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("memberTypeIdPtr")(
      elementType=memberTypeIdIrType,
      basePointer=valueCell,
      indices=memberTypeIdGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToMemberTypeId(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue, metadata : Map[String, Metadata] = Map())  {
    val memberTypeIdPtr = genPointerToMemberTypeId(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> memberTypeIdTbaaNode)
    block.store(toStore, memberTypeIdPtr, metadata=allMetadata)
  }

  def genLoadFromMemberTypeId(block : IrBlockBuilder)(valueCell : IrValue, metadata : Map[String, Metadata] = Map()) : IrValue = {
    val memberTypeIdPtr = genPointerToMemberTypeId(block)(valueCell)
    val allMetadata = Map("tbaa" -> memberTypeIdTbaaNode) ++ metadata
    block.load("memberTypeId")(memberTypeIdPtr, metadata=allMetadata)
  }

  def genPointerToListLength(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("listLengthPtr")(
      elementType=listLengthIrType,
      basePointer=valueCell,
      indices=listLengthGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToListLength(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue, metadata : Map[String, Metadata] = Map())  {
    val listLengthPtr = genPointerToListLength(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> listLengthTbaaNode)
    block.store(toStore, listLengthPtr, metadata=allMetadata)
  }

  def genLoadFromListLength(block : IrBlockBuilder)(valueCell : IrValue, metadata : Map[String, Metadata] = Map()) : IrValue = {
    val listLengthPtr = genPointerToListLength(block)(valueCell)
    val allMetadata = Map("tbaa" -> listLengthTbaaNode) ++ metadata
    block.load("listLength")(listLengthPtr, metadata=allMetadata)
  }

  def genPointerToCar(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("carPtr")(
      elementType=carIrType,
      basePointer=valueCell,
      indices=carGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToCar(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue, metadata : Map[String, Metadata] = Map())  {
    val carPtr = genPointerToCar(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> carTbaaNode)
    block.store(toStore, carPtr, metadata=allMetadata)
  }

  def genLoadFromCar(block : IrBlockBuilder)(valueCell : IrValue, metadata : Map[String, Metadata] = Map()) : IrValue = {
    val carPtr = genPointerToCar(block)(valueCell)
    val allMetadata = Map("tbaa" -> carTbaaNode) ++ metadata
    block.load("car")(carPtr, metadata=allMetadata)
  }

  def genPointerToCdr(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("cdrPtr")(
      elementType=cdrIrType,
      basePointer=valueCell,
      indices=cdrGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToCdr(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue, metadata : Map[String, Metadata] = Map())  {
    val cdrPtr = genPointerToCdr(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> cdrTbaaNode)
    block.store(toStore, cdrPtr, metadata=allMetadata)
  }

  def genLoadFromCdr(block : IrBlockBuilder)(valueCell : IrValue, metadata : Map[String, Metadata] = Map()) : IrValue = {
    val cdrPtr = genPointerToCdr(block)(valueCell)
    val allMetadata = Map("tbaa" -> cdrTbaaNode) ++ metadata
    block.load("cdr")(cdrPtr, metadata=allMetadata)
  }
}

object PairCell extends ConcreteCellType with PairFields {
  val llvmName = "pair"
  val irType = UserDefinedType("pair")
  val schemeName = "<pair-cell>"
  val directSubtypes = Set[CellType]()

  val typeId = 2L

  val typeIdGepIndices = List(0, 0, 0, 0)
  val gcStateGepIndices = List(0, 0, 0, 1)
  val memberTypeIdGepIndices = List(0, 1)
  val listLengthGepIndices = List(0, 2)
  val carGepIndices = List(0, 3)
  val cdrGepIndices = List(0, 4)

  val typeIdTbaaNode = NumberedMetadata(16L)
  val gcStateTbaaNode = NumberedMetadata(17L)
  val memberTypeIdTbaaNode = NumberedMetadata(18L)
  val listLengthTbaaNode = NumberedMetadata(19L)
  val carTbaaNode = NumberedMetadata(20L)
  val cdrTbaaNode = NumberedMetadata(21L)

  def createConstant(memberTypeId : Long, listLength : Long, car : IrConstant, cdr : IrConstant) : StructureConstant = {
    if (car.irType != carIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field car")
    }

    if (cdr.irType != cdrIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field cdr")
    }

    StructureConstant(List(
      ListElementCell.createConstant(typeId=typeId),
      IntegerConstant(memberTypeIdIrType, memberTypeId),
      IntegerConstant(listLengthIrType, listLength),
      car,
      cdr
    ), userDefinedType=Some(irType))
  }
}

sealed trait EmptyListFields extends ListElementFields {
  val irType : FirstClassType
}

object EmptyListCell extends PreconstructedCellType with EmptyListFields {
  val llvmName = "emptyList"
  val irType = UserDefinedType("emptyList")
  val schemeName = "<empty-list-cell>"
  val directSubtypes = Set[CellType]()

  val typeId = 3L

  val typeIdGepIndices = List(0, 0, 0, 0)
  val gcStateGepIndices = List(0, 0, 0, 1)

  val typeIdTbaaNode = NumberedMetadata(22L)
  val gcStateTbaaNode = NumberedMetadata(23L)
}

sealed trait StringFields extends DatumFields {
  val irType : FirstClassType

  val allocSlackBytesIrType = IntegerType(16)
  val allocSlackBytesTbaaNode : Metadata
  val allocSlackBytesGepIndices : List[Int]

  val charLengthIrType = IntegerType(32)
  val charLengthTbaaNode : Metadata
  val charLengthGepIndices : List[Int]

  val byteLengthIrType = IntegerType(32)
  val byteLengthTbaaNode : Metadata
  val byteLengthGepIndices : List[Int]

  def genPointerToAllocSlackBytes(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("allocSlackBytesPtr")(
      elementType=allocSlackBytesIrType,
      basePointer=valueCell,
      indices=allocSlackBytesGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToAllocSlackBytes(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue, metadata : Map[String, Metadata] = Map())  {
    val allocSlackBytesPtr = genPointerToAllocSlackBytes(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> allocSlackBytesTbaaNode)
    block.store(toStore, allocSlackBytesPtr, metadata=allMetadata)
  }

  def genLoadFromAllocSlackBytes(block : IrBlockBuilder)(valueCell : IrValue, metadata : Map[String, Metadata] = Map()) : IrValue = {
    val allocSlackBytesPtr = genPointerToAllocSlackBytes(block)(valueCell)
    val allMetadata = Map("tbaa" -> allocSlackBytesTbaaNode) ++ metadata
    block.load("allocSlackBytes")(allocSlackBytesPtr, metadata=allMetadata)
  }

  def genPointerToCharLength(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("charLengthPtr")(
      elementType=charLengthIrType,
      basePointer=valueCell,
      indices=charLengthGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToCharLength(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue, metadata : Map[String, Metadata] = Map())  {
    val charLengthPtr = genPointerToCharLength(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> charLengthTbaaNode)
    block.store(toStore, charLengthPtr, metadata=allMetadata)
  }

  def genLoadFromCharLength(block : IrBlockBuilder)(valueCell : IrValue, metadata : Map[String, Metadata] = Map()) : IrValue = {
    val charLengthPtr = genPointerToCharLength(block)(valueCell)
    val allMetadata = Map("tbaa" -> charLengthTbaaNode) ++ metadata
    block.load("charLength")(charLengthPtr, metadata=allMetadata)
  }

  def genPointerToByteLength(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("byteLengthPtr")(
      elementType=byteLengthIrType,
      basePointer=valueCell,
      indices=byteLengthGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToByteLength(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue, metadata : Map[String, Metadata] = Map())  {
    val byteLengthPtr = genPointerToByteLength(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> byteLengthTbaaNode)
    block.store(toStore, byteLengthPtr, metadata=allMetadata)
  }

  def genLoadFromByteLength(block : IrBlockBuilder)(valueCell : IrValue, metadata : Map[String, Metadata] = Map()) : IrValue = {
    val byteLengthPtr = genPointerToByteLength(block)(valueCell)
    val allMetadata = Map("tbaa" -> byteLengthTbaaNode) ++ metadata
    block.load("byteLength")(byteLengthPtr, metadata=allMetadata)
  }
}

object StringCell extends ConcreteCellType with StringFields {
  val llvmName = "string"
  val irType = UserDefinedType("string")
  val schemeName = "<string-cell>"
  val directSubtypes = Set[CellType]()

  val typeId = 4L

  val typeIdGepIndices = List(0, 0, 0)
  val gcStateGepIndices = List(0, 0, 1)
  val allocSlackBytesGepIndices = List(0, 1)
  val charLengthGepIndices = List(0, 2)
  val byteLengthGepIndices = List(0, 3)

  val typeIdTbaaNode = NumberedMetadata(24L)
  val gcStateTbaaNode = NumberedMetadata(25L)
  val allocSlackBytesTbaaNode = NumberedMetadata(26L)
  val charLengthTbaaNode = NumberedMetadata(27L)
  val byteLengthTbaaNode = NumberedMetadata(28L)

  def createConstant(allocSlackBytes : Long, charLength : Long, byteLength : Long) : StructureConstant = {
    StructureConstant(List(
      DatumCell.createConstant(typeId=typeId),
      IntegerConstant(allocSlackBytesIrType, allocSlackBytes),
      IntegerConstant(charLengthIrType, charLength),
      IntegerConstant(byteLengthIrType, byteLength)
    ), userDefinedType=Some(irType))
  }
}

sealed trait InlineStringFields extends StringFields {
  val irType : FirstClassType

  val inlineDataIrType = ArrayType(12, IntegerType(8))
  val inlineDataTbaaNode : Metadata
  val inlineDataGepIndices : List[Int]

  def genPointerToInlineData(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("inlineDataPtr")(
      elementType=inlineDataIrType,
      basePointer=valueCell,
      indices=inlineDataGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToInlineData(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue, metadata : Map[String, Metadata] = Map())  {
    val inlineDataPtr = genPointerToInlineData(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> inlineDataTbaaNode)
    block.store(toStore, inlineDataPtr, metadata=allMetadata)
  }

  def genLoadFromInlineData(block : IrBlockBuilder)(valueCell : IrValue, metadata : Map[String, Metadata] = Map()) : IrValue = {
    val inlineDataPtr = genPointerToInlineData(block)(valueCell)
    val allMetadata = Map("tbaa" -> inlineDataTbaaNode) ++ metadata
    block.load("inlineData")(inlineDataPtr, metadata=allMetadata)
  }
}

object InlineStringCell extends CellTypeVariant with InlineStringFields {
  val llvmName = "inlineString"
  val irType = UserDefinedType("inlineString")

  val typeIdGepIndices = List(0, 0, 0, 0)
  val gcStateGepIndices = List(0, 0, 0, 1)
  val allocSlackBytesGepIndices = List(0, 0, 1)
  val charLengthGepIndices = List(0, 0, 2)
  val byteLengthGepIndices = List(0, 0, 3)
  val inlineDataGepIndices = List(0, 1)

  val inlineDataTbaaNode = NumberedMetadata(29L)
  val typeIdTbaaNode = NumberedMetadata(24L)
  val gcStateTbaaNode = NumberedMetadata(25L)
  val allocSlackBytesTbaaNode = NumberedMetadata(26L)
  val charLengthTbaaNode = NumberedMetadata(27L)
  val byteLengthTbaaNode = NumberedMetadata(28L)

  def createConstant(inlineData : IrConstant, allocSlackBytes : Long, charLength : Long, byteLength : Long) : StructureConstant = {
    if (inlineData.irType != inlineDataIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field inlineData")
    }

    StructureConstant(List(
      StringCell.createConstant(allocSlackBytes=allocSlackBytes, charLength=charLength, byteLength=byteLength),
      inlineData
    ), userDefinedType=Some(irType))
  }
}

sealed trait HeapStringFields extends StringFields {
  val irType : FirstClassType

  val heapByteArrayIrType = PointerType(UserDefinedType("sharedByteArray"))
  val heapByteArrayTbaaNode : Metadata
  val heapByteArrayGepIndices : List[Int]

  def genPointerToHeapByteArray(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("heapByteArrayPtr")(
      elementType=heapByteArrayIrType,
      basePointer=valueCell,
      indices=heapByteArrayGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToHeapByteArray(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue, metadata : Map[String, Metadata] = Map())  {
    val heapByteArrayPtr = genPointerToHeapByteArray(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> heapByteArrayTbaaNode)
    block.store(toStore, heapByteArrayPtr, metadata=allMetadata)
  }

  def genLoadFromHeapByteArray(block : IrBlockBuilder)(valueCell : IrValue, metadata : Map[String, Metadata] = Map()) : IrValue = {
    val heapByteArrayPtr = genPointerToHeapByteArray(block)(valueCell)
    val allMetadata = Map("tbaa" -> heapByteArrayTbaaNode) ++ metadata
    block.load("heapByteArray")(heapByteArrayPtr, metadata=allMetadata)
  }
}

object HeapStringCell extends CellTypeVariant with HeapStringFields {
  val llvmName = "heapString"
  val irType = UserDefinedType("heapString")

  val typeIdGepIndices = List(0, 0, 0, 0)
  val gcStateGepIndices = List(0, 0, 0, 1)
  val allocSlackBytesGepIndices = List(0, 0, 1)
  val charLengthGepIndices = List(0, 0, 2)
  val byteLengthGepIndices = List(0, 0, 3)
  val heapByteArrayGepIndices = List(0, 1)

  val heapByteArrayTbaaNode = NumberedMetadata(30L)
  val typeIdTbaaNode = NumberedMetadata(24L)
  val gcStateTbaaNode = NumberedMetadata(25L)
  val allocSlackBytesTbaaNode = NumberedMetadata(26L)
  val charLengthTbaaNode = NumberedMetadata(27L)
  val byteLengthTbaaNode = NumberedMetadata(28L)

  def createConstant(heapByteArray : IrConstant, allocSlackBytes : Long, charLength : Long, byteLength : Long) : StructureConstant = {
    if (heapByteArray.irType != heapByteArrayIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field heapByteArray")
    }

    StructureConstant(List(
      StringCell.createConstant(allocSlackBytes=allocSlackBytes, charLength=charLength, byteLength=byteLength),
      heapByteArray
    ), userDefinedType=Some(irType))
  }
}

sealed trait SymbolFields extends DatumFields {
  val irType : FirstClassType

  val charLengthIrType = IntegerType(32)
  val charLengthTbaaNode : Metadata
  val charLengthGepIndices : List[Int]

  val byteLengthIrType = IntegerType(32)
  val byteLengthTbaaNode : Metadata
  val byteLengthGepIndices : List[Int]

  def genPointerToCharLength(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("charLengthPtr")(
      elementType=charLengthIrType,
      basePointer=valueCell,
      indices=charLengthGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToCharLength(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue, metadata : Map[String, Metadata] = Map())  {
    val charLengthPtr = genPointerToCharLength(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> charLengthTbaaNode)
    block.store(toStore, charLengthPtr, metadata=allMetadata)
  }

  def genLoadFromCharLength(block : IrBlockBuilder)(valueCell : IrValue, metadata : Map[String, Metadata] = Map()) : IrValue = {
    val charLengthPtr = genPointerToCharLength(block)(valueCell)
    val allMetadata = Map("tbaa" -> charLengthTbaaNode) ++ metadata
    block.load("charLength")(charLengthPtr, metadata=allMetadata)
  }

  def genPointerToByteLength(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("byteLengthPtr")(
      elementType=byteLengthIrType,
      basePointer=valueCell,
      indices=byteLengthGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToByteLength(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue, metadata : Map[String, Metadata] = Map())  {
    val byteLengthPtr = genPointerToByteLength(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> byteLengthTbaaNode)
    block.store(toStore, byteLengthPtr, metadata=allMetadata)
  }

  def genLoadFromByteLength(block : IrBlockBuilder)(valueCell : IrValue, metadata : Map[String, Metadata] = Map()) : IrValue = {
    val byteLengthPtr = genPointerToByteLength(block)(valueCell)
    val allMetadata = Map("tbaa" -> byteLengthTbaaNode) ++ metadata
    block.load("byteLength")(byteLengthPtr, metadata=allMetadata)
  }
}

object SymbolCell extends ConcreteCellType with SymbolFields {
  val llvmName = "symbol"
  val irType = UserDefinedType("symbol")
  val schemeName = "<symbol-cell>"
  val directSubtypes = Set[CellType]()

  val typeId = 5L

  val typeIdGepIndices = List(0, 0, 0)
  val gcStateGepIndices = List(0, 0, 1)
  val charLengthGepIndices = List(0, 1)
  val byteLengthGepIndices = List(0, 2)

  val typeIdTbaaNode = NumberedMetadata(31L)
  val gcStateTbaaNode = NumberedMetadata(32L)
  val charLengthTbaaNode = NumberedMetadata(33L)
  val byteLengthTbaaNode = NumberedMetadata(34L)

  def createConstant(charLength : Long, byteLength : Long) : StructureConstant = {
    StructureConstant(List(
      DatumCell.createConstant(typeId=typeId),
      IntegerConstant(charLengthIrType, charLength),
      IntegerConstant(byteLengthIrType, byteLength)
    ), userDefinedType=Some(irType))
  }
}

sealed trait InlineSymbolFields extends SymbolFields {
  val irType : FirstClassType

  val inlineDataIrType = ArrayType(12, IntegerType(8))
  val inlineDataTbaaNode : Metadata
  val inlineDataGepIndices : List[Int]

  def genPointerToInlineData(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("inlineDataPtr")(
      elementType=inlineDataIrType,
      basePointer=valueCell,
      indices=inlineDataGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToInlineData(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue, metadata : Map[String, Metadata] = Map())  {
    val inlineDataPtr = genPointerToInlineData(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> inlineDataTbaaNode)
    block.store(toStore, inlineDataPtr, metadata=allMetadata)
  }

  def genLoadFromInlineData(block : IrBlockBuilder)(valueCell : IrValue, metadata : Map[String, Metadata] = Map()) : IrValue = {
    val inlineDataPtr = genPointerToInlineData(block)(valueCell)
    val allMetadata = Map("tbaa" -> inlineDataTbaaNode) ++ metadata
    block.load("inlineData")(inlineDataPtr, metadata=allMetadata)
  }
}

object InlineSymbolCell extends CellTypeVariant with InlineSymbolFields {
  val llvmName = "inlineSymbol"
  val irType = UserDefinedType("inlineSymbol")

  val typeIdGepIndices = List(0, 0, 0, 0)
  val gcStateGepIndices = List(0, 0, 0, 1)
  val charLengthGepIndices = List(0, 0, 1)
  val byteLengthGepIndices = List(0, 0, 2)
  val inlineDataGepIndices = List(0, 1)

  val inlineDataTbaaNode = NumberedMetadata(35L)
  val typeIdTbaaNode = NumberedMetadata(31L)
  val gcStateTbaaNode = NumberedMetadata(32L)
  val charLengthTbaaNode = NumberedMetadata(33L)
  val byteLengthTbaaNode = NumberedMetadata(34L)

  def createConstant(inlineData : IrConstant, charLength : Long, byteLength : Long) : StructureConstant = {
    if (inlineData.irType != inlineDataIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field inlineData")
    }

    StructureConstant(List(
      SymbolCell.createConstant(charLength=charLength, byteLength=byteLength),
      inlineData
    ), userDefinedType=Some(irType))
  }
}

sealed trait HeapSymbolFields extends SymbolFields {
  val irType : FirstClassType

  val heapByteArrayIrType = PointerType(UserDefinedType("sharedByteArray"))
  val heapByteArrayTbaaNode : Metadata
  val heapByteArrayGepIndices : List[Int]

  def genPointerToHeapByteArray(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("heapByteArrayPtr")(
      elementType=heapByteArrayIrType,
      basePointer=valueCell,
      indices=heapByteArrayGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToHeapByteArray(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue, metadata : Map[String, Metadata] = Map())  {
    val heapByteArrayPtr = genPointerToHeapByteArray(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> heapByteArrayTbaaNode)
    block.store(toStore, heapByteArrayPtr, metadata=allMetadata)
  }

  def genLoadFromHeapByteArray(block : IrBlockBuilder)(valueCell : IrValue, metadata : Map[String, Metadata] = Map()) : IrValue = {
    val heapByteArrayPtr = genPointerToHeapByteArray(block)(valueCell)
    val allMetadata = Map("tbaa" -> heapByteArrayTbaaNode) ++ metadata
    block.load("heapByteArray")(heapByteArrayPtr, metadata=allMetadata)
  }
}

object HeapSymbolCell extends CellTypeVariant with HeapSymbolFields {
  val llvmName = "heapSymbol"
  val irType = UserDefinedType("heapSymbol")

  val typeIdGepIndices = List(0, 0, 0, 0)
  val gcStateGepIndices = List(0, 0, 0, 1)
  val charLengthGepIndices = List(0, 0, 1)
  val byteLengthGepIndices = List(0, 0, 2)
  val heapByteArrayGepIndices = List(0, 1)

  val heapByteArrayTbaaNode = NumberedMetadata(36L)
  val typeIdTbaaNode = NumberedMetadata(31L)
  val gcStateTbaaNode = NumberedMetadata(32L)
  val charLengthTbaaNode = NumberedMetadata(33L)
  val byteLengthTbaaNode = NumberedMetadata(34L)

  def createConstant(heapByteArray : IrConstant, charLength : Long, byteLength : Long) : StructureConstant = {
    if (heapByteArray.irType != heapByteArrayIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field heapByteArray")
    }

    StructureConstant(List(
      SymbolCell.createConstant(charLength=charLength, byteLength=byteLength),
      heapByteArray
    ), userDefinedType=Some(irType))
  }
}

sealed trait BooleanFields extends DatumFields {
  val irType : FirstClassType

  val valueIrType = IntegerType(8)
  val valueTbaaNode : Metadata
  val valueGepIndices : List[Int]

  def genPointerToValue(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("valuePtr")(
      elementType=valueIrType,
      basePointer=valueCell,
      indices=valueGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToValue(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue, metadata : Map[String, Metadata] = Map())  {
    val valuePtr = genPointerToValue(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> valueTbaaNode)
    block.store(toStore, valuePtr, metadata=allMetadata)
  }

  def genLoadFromValue(block : IrBlockBuilder)(valueCell : IrValue, metadata : Map[String, Metadata] = Map()) : IrValue = {
    val valuePtr = genPointerToValue(block)(valueCell)
    val allMetadata = Map("tbaa" -> valueTbaaNode) ++ metadata
    block.load("value")(valuePtr, metadata=allMetadata)
  }
}

object BooleanCell extends PreconstructedCellType with BooleanFields {
  val llvmName = "boolean"
  val irType = UserDefinedType("boolean")
  val schemeName = "<boolean-cell>"
  val directSubtypes = Set[CellType]()

  val typeId = 6L

  val typeIdGepIndices = List(0, 0, 0)
  val gcStateGepIndices = List(0, 0, 1)
  val valueGepIndices = List(0, 1)

  val typeIdTbaaNode = NumberedMetadata(37L)
  val gcStateTbaaNode = NumberedMetadata(38L)
  val valueTbaaNode = NumberedMetadata(39L)
}

sealed trait NumericFields extends DatumFields {
  val irType : FirstClassType
}

object NumericCell extends CellType with NumericFields {
  val llvmName = "numeric"
  val irType = UserDefinedType("numeric")
  val schemeName = "<numeric-cell>"
  val directSubtypes = Set[CellType](ExactIntegerCell, InexactRationalCell)

  val typeIdGepIndices = List(0, 0, 0)
  val gcStateGepIndices = List(0, 0, 1)

  val typeIdTbaaNode = NumberedMetadata(40L)
  val gcStateTbaaNode = NumberedMetadata(41L)

  def createConstant(typeId : Long) : StructureConstant = {
    StructureConstant(List(
      DatumCell.createConstant(typeId=typeId)
    ), userDefinedType=Some(irType))
  }
}

sealed trait ExactIntegerFields extends NumericFields {
  val irType : FirstClassType

  val valueIrType = IntegerType(64)
  val valueTbaaNode : Metadata
  val valueGepIndices : List[Int]

  def genPointerToValue(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("valuePtr")(
      elementType=valueIrType,
      basePointer=valueCell,
      indices=valueGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToValue(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue, metadata : Map[String, Metadata] = Map())  {
    val valuePtr = genPointerToValue(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> valueTbaaNode)
    block.store(toStore, valuePtr, metadata=allMetadata)
  }

  def genLoadFromValue(block : IrBlockBuilder)(valueCell : IrValue, metadata : Map[String, Metadata] = Map()) : IrValue = {
    val valuePtr = genPointerToValue(block)(valueCell)
    val allMetadata = Map("tbaa" -> valueTbaaNode) ++ metadata
    block.load("value")(valuePtr, metadata=allMetadata)
  }
}

object ExactIntegerCell extends ConcreteCellType with ExactIntegerFields {
  val llvmName = "exactInteger"
  val irType = UserDefinedType("exactInteger")
  val schemeName = "<exact-integer-cell>"
  val directSubtypes = Set[CellType]()

  val typeId = 7L

  val typeIdGepIndices = List(0, 0, 0, 0)
  val gcStateGepIndices = List(0, 0, 0, 1)
  val valueGepIndices = List(0, 1)

  val typeIdTbaaNode = NumberedMetadata(42L)
  val gcStateTbaaNode = NumberedMetadata(43L)
  val valueTbaaNode = NumberedMetadata(44L)

  def createConstant(value : Long) : StructureConstant = {
    StructureConstant(List(
      NumericCell.createConstant(typeId=typeId),
      IntegerConstant(valueIrType, value)
    ), userDefinedType=Some(irType))
  }
}

sealed trait InexactRationalFields extends NumericFields {
  val irType : FirstClassType

  val valueIrType = DoubleType
  val valueTbaaNode : Metadata
  val valueGepIndices : List[Int]

  def genPointerToValue(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("valuePtr")(
      elementType=valueIrType,
      basePointer=valueCell,
      indices=valueGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToValue(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue, metadata : Map[String, Metadata] = Map())  {
    val valuePtr = genPointerToValue(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> valueTbaaNode)
    block.store(toStore, valuePtr, metadata=allMetadata)
  }

  def genLoadFromValue(block : IrBlockBuilder)(valueCell : IrValue, metadata : Map[String, Metadata] = Map()) : IrValue = {
    val valuePtr = genPointerToValue(block)(valueCell)
    val allMetadata = Map("tbaa" -> valueTbaaNode) ++ metadata
    block.load("value")(valuePtr, metadata=allMetadata)
  }
}

object InexactRationalCell extends ConcreteCellType with InexactRationalFields {
  val llvmName = "inexactRational"
  val irType = UserDefinedType("inexactRational")
  val schemeName = "<inexact-rational-cell>"
  val directSubtypes = Set[CellType]()

  val typeId = 8L

  val typeIdGepIndices = List(0, 0, 0, 0)
  val gcStateGepIndices = List(0, 0, 0, 1)
  val valueGepIndices = List(0, 1)

  val typeIdTbaaNode = NumberedMetadata(45L)
  val gcStateTbaaNode = NumberedMetadata(46L)
  val valueTbaaNode = NumberedMetadata(47L)

  def createConstant(value : IrConstant) : StructureConstant = {
    if (value.irType != valueIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field value")
    }

    StructureConstant(List(
      NumericCell.createConstant(typeId=typeId),
      value
    ), userDefinedType=Some(irType))
  }
}

sealed trait CharacterFields extends DatumFields {
  val irType : FirstClassType

  val unicodeCharIrType = IntegerType(32)
  val unicodeCharTbaaNode : Metadata
  val unicodeCharGepIndices : List[Int]

  def genPointerToUnicodeChar(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("unicodeCharPtr")(
      elementType=unicodeCharIrType,
      basePointer=valueCell,
      indices=unicodeCharGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToUnicodeChar(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue, metadata : Map[String, Metadata] = Map())  {
    val unicodeCharPtr = genPointerToUnicodeChar(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> unicodeCharTbaaNode)
    block.store(toStore, unicodeCharPtr, metadata=allMetadata)
  }

  def genLoadFromUnicodeChar(block : IrBlockBuilder)(valueCell : IrValue, metadata : Map[String, Metadata] = Map()) : IrValue = {
    val unicodeCharPtr = genPointerToUnicodeChar(block)(valueCell)
    val allMetadata = Map("tbaa" -> unicodeCharTbaaNode) ++ metadata
    block.load("unicodeChar")(unicodeCharPtr, metadata=allMetadata)
  }
}

object CharacterCell extends ConcreteCellType with CharacterFields {
  val llvmName = "character"
  val irType = UserDefinedType("character")
  val schemeName = "<character-cell>"
  val directSubtypes = Set[CellType]()

  val typeId = 9L

  val typeIdGepIndices = List(0, 0, 0)
  val gcStateGepIndices = List(0, 0, 1)
  val unicodeCharGepIndices = List(0, 1)

  val typeIdTbaaNode = NumberedMetadata(48L)
  val gcStateTbaaNode = NumberedMetadata(49L)
  val unicodeCharTbaaNode = NumberedMetadata(50L)

  def createConstant(unicodeChar : Long) : StructureConstant = {
    StructureConstant(List(
      DatumCell.createConstant(typeId=typeId),
      IntegerConstant(unicodeCharIrType, unicodeChar)
    ), userDefinedType=Some(irType))
  }
}

sealed trait VectorFields extends DatumFields {
  val irType : FirstClassType

  val lengthIrType = IntegerType(32)
  val lengthTbaaNode : Metadata
  val lengthGepIndices : List[Int]

  val elementsIrType = PointerType(PointerType(UserDefinedType("datum")))
  val elementsTbaaNode : Metadata
  val elementsGepIndices : List[Int]

  def genPointerToLength(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("lengthPtr")(
      elementType=lengthIrType,
      basePointer=valueCell,
      indices=lengthGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToLength(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue, metadata : Map[String, Metadata] = Map())  {
    val lengthPtr = genPointerToLength(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> lengthTbaaNode)
    block.store(toStore, lengthPtr, metadata=allMetadata)
  }

  def genLoadFromLength(block : IrBlockBuilder)(valueCell : IrValue, metadata : Map[String, Metadata] = Map()) : IrValue = {
    val lengthPtr = genPointerToLength(block)(valueCell)
    val allMetadata = Map("tbaa" -> lengthTbaaNode) ++ metadata
    block.load("length")(lengthPtr, metadata=allMetadata)
  }

  def genPointerToElements(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("elementsPtr")(
      elementType=elementsIrType,
      basePointer=valueCell,
      indices=elementsGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToElements(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue, metadata : Map[String, Metadata] = Map())  {
    val elementsPtr = genPointerToElements(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> elementsTbaaNode)
    block.store(toStore, elementsPtr, metadata=allMetadata)
  }

  def genLoadFromElements(block : IrBlockBuilder)(valueCell : IrValue, metadata : Map[String, Metadata] = Map()) : IrValue = {
    val elementsPtr = genPointerToElements(block)(valueCell)
    val allMetadata = Map("tbaa" -> elementsTbaaNode) ++ metadata
    block.load("elements")(elementsPtr, metadata=allMetadata)
  }
}

object VectorCell extends ConcreteCellType with VectorFields {
  val llvmName = "vector"
  val irType = UserDefinedType("vector")
  val schemeName = "<vector-cell>"
  val directSubtypes = Set[CellType]()

  val typeId = 10L

  val typeIdGepIndices = List(0, 0, 0)
  val gcStateGepIndices = List(0, 0, 1)
  val lengthGepIndices = List(0, 1)
  val elementsGepIndices = List(0, 2)

  val typeIdTbaaNode = NumberedMetadata(51L)
  val gcStateTbaaNode = NumberedMetadata(52L)
  val lengthTbaaNode = NumberedMetadata(53L)
  val elementsTbaaNode = NumberedMetadata(54L)

  def createConstant(length : Long, elements : IrConstant) : StructureConstant = {
    if (elements.irType != elementsIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field elements")
    }

    StructureConstant(List(
      DatumCell.createConstant(typeId=typeId),
      IntegerConstant(lengthIrType, length),
      elements
    ), userDefinedType=Some(irType))
  }
}

sealed trait BytevectorFields extends DatumFields {
  val irType : FirstClassType

  val lengthIrType = IntegerType(32)
  val lengthTbaaNode : Metadata
  val lengthGepIndices : List[Int]

  val byteArrayIrType = PointerType(UserDefinedType("sharedByteArray"))
  val byteArrayTbaaNode : Metadata
  val byteArrayGepIndices : List[Int]

  def genPointerToLength(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("lengthPtr")(
      elementType=lengthIrType,
      basePointer=valueCell,
      indices=lengthGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToLength(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue, metadata : Map[String, Metadata] = Map())  {
    val lengthPtr = genPointerToLength(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> lengthTbaaNode)
    block.store(toStore, lengthPtr, metadata=allMetadata)
  }

  def genLoadFromLength(block : IrBlockBuilder)(valueCell : IrValue, metadata : Map[String, Metadata] = Map()) : IrValue = {
    val lengthPtr = genPointerToLength(block)(valueCell)
    val allMetadata = Map("tbaa" -> lengthTbaaNode) ++ metadata
    block.load("length")(lengthPtr, metadata=allMetadata)
  }

  def genPointerToByteArray(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("byteArrayPtr")(
      elementType=byteArrayIrType,
      basePointer=valueCell,
      indices=byteArrayGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToByteArray(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue, metadata : Map[String, Metadata] = Map())  {
    val byteArrayPtr = genPointerToByteArray(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> byteArrayTbaaNode)
    block.store(toStore, byteArrayPtr, metadata=allMetadata)
  }

  def genLoadFromByteArray(block : IrBlockBuilder)(valueCell : IrValue, metadata : Map[String, Metadata] = Map()) : IrValue = {
    val byteArrayPtr = genPointerToByteArray(block)(valueCell)
    val allMetadata = Map("tbaa" -> byteArrayTbaaNode) ++ metadata
    block.load("byteArray")(byteArrayPtr, metadata=allMetadata)
  }
}

object BytevectorCell extends ConcreteCellType with BytevectorFields {
  val llvmName = "bytevector"
  val irType = UserDefinedType("bytevector")
  val schemeName = "<bytevector-cell>"
  val directSubtypes = Set[CellType]()

  val typeId = 11L

  val typeIdGepIndices = List(0, 0, 0)
  val gcStateGepIndices = List(0, 0, 1)
  val lengthGepIndices = List(0, 1)
  val byteArrayGepIndices = List(0, 2)

  val typeIdTbaaNode = NumberedMetadata(55L)
  val gcStateTbaaNode = NumberedMetadata(56L)
  val lengthTbaaNode = NumberedMetadata(57L)
  val byteArrayTbaaNode = NumberedMetadata(58L)

  def createConstant(length : Long, byteArray : IrConstant) : StructureConstant = {
    if (byteArray.irType != byteArrayIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field byteArray")
    }

    StructureConstant(List(
      DatumCell.createConstant(typeId=typeId),
      IntegerConstant(lengthIrType, length),
      byteArray
    ), userDefinedType=Some(irType))
  }
}

sealed trait RecordLikeFields extends DatumFields {
  val irType : FirstClassType

  val dataIsInlineIrType = IntegerType(8)
  val dataIsInlineTbaaNode : Metadata
  val dataIsInlineGepIndices : List[Int]

  val isUndefinedIrType = IntegerType(8)
  val isUndefinedTbaaNode : Metadata
  val isUndefinedGepIndices : List[Int]

  val recordClassIdIrType = IntegerType(32)
  val recordClassIdTbaaNode : Metadata
  val recordClassIdGepIndices : List[Int]

  val recordDataIrType = PointerType(IntegerType(8))
  val recordDataTbaaNode : Metadata
  val recordDataGepIndices : List[Int]

  def genPointerToDataIsInline(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("dataIsInlinePtr")(
      elementType=dataIsInlineIrType,
      basePointer=valueCell,
      indices=dataIsInlineGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToDataIsInline(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue, metadata : Map[String, Metadata] = Map())  {
    val dataIsInlinePtr = genPointerToDataIsInline(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> dataIsInlineTbaaNode)
    block.store(toStore, dataIsInlinePtr, metadata=allMetadata)
  }

  def genLoadFromDataIsInline(block : IrBlockBuilder)(valueCell : IrValue, metadata : Map[String, Metadata] = Map()) : IrValue = {
    val dataIsInlinePtr = genPointerToDataIsInline(block)(valueCell)
    val allMetadata = Map("tbaa" -> dataIsInlineTbaaNode) ++ metadata
    block.load("dataIsInline")(dataIsInlinePtr, metadata=allMetadata)
  }

  def genPointerToIsUndefined(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("isUndefinedPtr")(
      elementType=isUndefinedIrType,
      basePointer=valueCell,
      indices=isUndefinedGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToIsUndefined(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue, metadata : Map[String, Metadata] = Map())  {
    val isUndefinedPtr = genPointerToIsUndefined(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> isUndefinedTbaaNode)
    block.store(toStore, isUndefinedPtr, metadata=allMetadata)
  }

  def genLoadFromIsUndefined(block : IrBlockBuilder)(valueCell : IrValue, metadata : Map[String, Metadata] = Map()) : IrValue = {
    val isUndefinedPtr = genPointerToIsUndefined(block)(valueCell)
    val allMetadata = Map("tbaa" -> isUndefinedTbaaNode) ++ metadata
    block.load("isUndefined")(isUndefinedPtr, metadata=allMetadata)
  }

  def genPointerToRecordClassId(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("recordClassIdPtr")(
      elementType=recordClassIdIrType,
      basePointer=valueCell,
      indices=recordClassIdGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToRecordClassId(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue, metadata : Map[String, Metadata] = Map())  {
    val recordClassIdPtr = genPointerToRecordClassId(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> recordClassIdTbaaNode)
    block.store(toStore, recordClassIdPtr, metadata=allMetadata)
  }

  def genLoadFromRecordClassId(block : IrBlockBuilder)(valueCell : IrValue, metadata : Map[String, Metadata] = Map()) : IrValue = {
    val recordClassIdPtr = genPointerToRecordClassId(block)(valueCell)
    val allMetadata = Map("tbaa" -> recordClassIdTbaaNode) ++ metadata
    block.load("recordClassId")(recordClassIdPtr, metadata=allMetadata)
  }

  def genPointerToRecordData(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("recordDataPtr")(
      elementType=recordDataIrType,
      basePointer=valueCell,
      indices=recordDataGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToRecordData(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue, metadata : Map[String, Metadata] = Map())  {
    val recordDataPtr = genPointerToRecordData(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> recordDataTbaaNode)
    block.store(toStore, recordDataPtr, metadata=allMetadata)
  }

  def genLoadFromRecordData(block : IrBlockBuilder)(valueCell : IrValue, metadata : Map[String, Metadata] = Map()) : IrValue = {
    val recordDataPtr = genPointerToRecordData(block)(valueCell)
    val allMetadata = Map("tbaa" -> recordDataTbaaNode) ++ metadata
    block.load("recordData")(recordDataPtr, metadata=allMetadata)
  }
}

object RecordLikeCell extends CellType with RecordLikeFields {
  val llvmName = "recordLike"
  val irType = UserDefinedType("recordLike")
  val schemeName = "<record-like-cell>"
  val directSubtypes = Set[CellType](ProcedureCell, RecordCell)

  val typeIdGepIndices = List(0, 0, 0)
  val gcStateGepIndices = List(0, 0, 1)
  val dataIsInlineGepIndices = List(0, 1)
  val isUndefinedGepIndices = List(0, 2)
  val recordClassIdGepIndices = List(0, 3)
  val recordDataGepIndices = List(0, 4)

  val typeIdTbaaNode = NumberedMetadata(59L)
  val gcStateTbaaNode = NumberedMetadata(60L)
  val dataIsInlineTbaaNode = NumberedMetadata(61L)
  val isUndefinedTbaaNode = NumberedMetadata(62L)
  val recordClassIdTbaaNode = NumberedMetadata(63L)
  val recordDataTbaaNode = NumberedMetadata(64L)

  def createConstant(dataIsInline : Long, isUndefined : Long, recordClassId : Long, recordData : IrConstant, typeId : Long) : StructureConstant = {
    if (recordData.irType != recordDataIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field recordData")
    }

    StructureConstant(List(
      DatumCell.createConstant(typeId=typeId),
      IntegerConstant(dataIsInlineIrType, dataIsInline),
      IntegerConstant(isUndefinedIrType, isUndefined),
      IntegerConstant(recordClassIdIrType, recordClassId),
      recordData
    ), userDefinedType=Some(irType))
  }
}

sealed trait ProcedureFields extends RecordLikeFields {
  val irType : FirstClassType

  val entryPointIrType = PointerType(FunctionType(PointerType(UserDefinedType("datum")), List(PointerType(UserDefinedType("world")), PointerType(UserDefinedType("procedure")), PointerType(UserDefinedType("listElement"))), false))
  val entryPointTbaaNode : Metadata
  val entryPointGepIndices : List[Int]

  def genPointerToEntryPoint(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("entryPointPtr")(
      elementType=entryPointIrType,
      basePointer=valueCell,
      indices=entryPointGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToEntryPoint(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue, metadata : Map[String, Metadata] = Map())  {
    val entryPointPtr = genPointerToEntryPoint(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> entryPointTbaaNode)
    block.store(toStore, entryPointPtr, metadata=allMetadata)
  }

  def genLoadFromEntryPoint(block : IrBlockBuilder)(valueCell : IrValue, metadata : Map[String, Metadata] = Map()) : IrValue = {
    val entryPointPtr = genPointerToEntryPoint(block)(valueCell)
    val allMetadata = Map("tbaa" -> entryPointTbaaNode) ++ metadata
    block.load("entryPoint")(entryPointPtr, metadata=allMetadata)
  }
}

object ProcedureCell extends ConcreteCellType with ProcedureFields {
  val llvmName = "procedure"
  val irType = UserDefinedType("procedure")
  val schemeName = "<procedure-cell>"
  val directSubtypes = Set[CellType]()

  val typeId = 12L

  val typeIdGepIndices = List(0, 0, 0, 0)
  val gcStateGepIndices = List(0, 0, 0, 1)
  val dataIsInlineGepIndices = List(0, 0, 1)
  val isUndefinedGepIndices = List(0, 0, 2)
  val recordClassIdGepIndices = List(0, 0, 3)
  val recordDataGepIndices = List(0, 0, 4)
  val entryPointGepIndices = List(0, 1)

  val typeIdTbaaNode = NumberedMetadata(65L)
  val gcStateTbaaNode = NumberedMetadata(66L)
  val dataIsInlineTbaaNode = NumberedMetadata(67L)
  val isUndefinedTbaaNode = NumberedMetadata(68L)
  val recordClassIdTbaaNode = NumberedMetadata(69L)
  val recordDataTbaaNode = NumberedMetadata(70L)
  val entryPointTbaaNode = NumberedMetadata(71L)

  def createConstant(entryPoint : IrConstant, dataIsInline : Long, isUndefined : Long, recordClassId : Long, recordData : IrConstant) : StructureConstant = {
    if (entryPoint.irType != entryPointIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field entryPoint")
    }

    StructureConstant(List(
      RecordLikeCell.createConstant(dataIsInline=dataIsInline, isUndefined=isUndefined, recordClassId=recordClassId, recordData=recordData, typeId=typeId),
      entryPoint
    ), userDefinedType=Some(irType))
  }
}

sealed trait RecordFields extends RecordLikeFields {
  val irType : FirstClassType

  val extraDataIrType = PointerType(IntegerType(8))
  val extraDataTbaaNode : Metadata
  val extraDataGepIndices : List[Int]

  def genPointerToExtraData(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("extraDataPtr")(
      elementType=extraDataIrType,
      basePointer=valueCell,
      indices=extraDataGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToExtraData(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue, metadata : Map[String, Metadata] = Map())  {
    val extraDataPtr = genPointerToExtraData(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> extraDataTbaaNode)
    block.store(toStore, extraDataPtr, metadata=allMetadata)
  }

  def genLoadFromExtraData(block : IrBlockBuilder)(valueCell : IrValue, metadata : Map[String, Metadata] = Map()) : IrValue = {
    val extraDataPtr = genPointerToExtraData(block)(valueCell)
    val allMetadata = Map("tbaa" -> extraDataTbaaNode) ++ metadata
    block.load("extraData")(extraDataPtr, metadata=allMetadata)
  }
}

object RecordCell extends ConcreteCellType with RecordFields {
  val llvmName = "record"
  val irType = UserDefinedType("record")
  val schemeName = "<record-cell>"
  val directSubtypes = Set[CellType]()

  val typeId = 13L

  val typeIdGepIndices = List(0, 0, 0, 0)
  val gcStateGepIndices = List(0, 0, 0, 1)
  val dataIsInlineGepIndices = List(0, 0, 1)
  val isUndefinedGepIndices = List(0, 0, 2)
  val recordClassIdGepIndices = List(0, 0, 3)
  val recordDataGepIndices = List(0, 0, 4)
  val extraDataGepIndices = List(0, 1)

  val typeIdTbaaNode = NumberedMetadata(72L)
  val gcStateTbaaNode = NumberedMetadata(73L)
  val dataIsInlineTbaaNode = NumberedMetadata(74L)
  val isUndefinedTbaaNode = NumberedMetadata(75L)
  val recordClassIdTbaaNode = NumberedMetadata(76L)
  val recordDataTbaaNode = NumberedMetadata(77L)
  val extraDataTbaaNode = NumberedMetadata(78L)

  def createConstant(extraData : IrConstant, dataIsInline : Long, isUndefined : Long, recordClassId : Long, recordData : IrConstant) : StructureConstant = {
    if (extraData.irType != extraDataIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field extraData")
    }

    StructureConstant(List(
      RecordLikeCell.createConstant(dataIsInline=dataIsInline, isUndefined=isUndefined, recordClassId=recordClassId, recordData=recordData, typeId=typeId),
      extraData
    ), userDefinedType=Some(irType))
  }
}

sealed trait ErrorObjectFields extends DatumFields {
  val irType : FirstClassType

  val messageIrType = PointerType(UserDefinedType("string"))
  val messageTbaaNode : Metadata
  val messageGepIndices : List[Int]

  val irritantsIrType = PointerType(UserDefinedType("listElement"))
  val irritantsTbaaNode : Metadata
  val irritantsGepIndices : List[Int]

  def genPointerToMessage(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("messagePtr")(
      elementType=messageIrType,
      basePointer=valueCell,
      indices=messageGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToMessage(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue, metadata : Map[String, Metadata] = Map())  {
    val messagePtr = genPointerToMessage(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> messageTbaaNode)
    block.store(toStore, messagePtr, metadata=allMetadata)
  }

  def genLoadFromMessage(block : IrBlockBuilder)(valueCell : IrValue, metadata : Map[String, Metadata] = Map()) : IrValue = {
    val messagePtr = genPointerToMessage(block)(valueCell)
    val allMetadata = Map("tbaa" -> messageTbaaNode) ++ metadata
    block.load("message")(messagePtr, metadata=allMetadata)
  }

  def genPointerToIrritants(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("irritantsPtr")(
      elementType=irritantsIrType,
      basePointer=valueCell,
      indices=irritantsGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToIrritants(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue, metadata : Map[String, Metadata] = Map())  {
    val irritantsPtr = genPointerToIrritants(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> irritantsTbaaNode)
    block.store(toStore, irritantsPtr, metadata=allMetadata)
  }

  def genLoadFromIrritants(block : IrBlockBuilder)(valueCell : IrValue, metadata : Map[String, Metadata] = Map()) : IrValue = {
    val irritantsPtr = genPointerToIrritants(block)(valueCell)
    val allMetadata = Map("tbaa" -> irritantsTbaaNode) ++ metadata
    block.load("irritants")(irritantsPtr, metadata=allMetadata)
  }
}

object ErrorObjectCell extends ConcreteCellType with ErrorObjectFields {
  val llvmName = "errorObject"
  val irType = UserDefinedType("errorObject")
  val schemeName = "<error-object-cell>"
  val directSubtypes = Set[CellType]()

  val typeId = 14L

  val typeIdGepIndices = List(0, 0, 0)
  val gcStateGepIndices = List(0, 0, 1)
  val messageGepIndices = List(0, 1)
  val irritantsGepIndices = List(0, 2)

  val typeIdTbaaNode = NumberedMetadata(79L)
  val gcStateTbaaNode = NumberedMetadata(80L)
  val messageTbaaNode = NumberedMetadata(81L)
  val irritantsTbaaNode = NumberedMetadata(82L)

  def createConstant(message : IrConstant, irritants : IrConstant) : StructureConstant = {
    if (message.irType != messageIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field message")
    }

    if (irritants.irType != irritantsIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field irritants")
    }

    StructureConstant(List(
      DatumCell.createConstant(typeId=typeId),
      message,
      irritants
    ), userDefinedType=Some(irType))
  }
}

sealed trait PortFields extends DatumFields {
  val irType : FirstClassType

  val isOwnedIrType = IntegerType(8)
  val isOwnedTbaaNode : Metadata
  val isOwnedGepIndices : List[Int]

  val streamIrType = PointerType(IntegerType(8))
  val streamTbaaNode : Metadata
  val streamGepIndices : List[Int]

  def genPointerToIsOwned(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("isOwnedPtr")(
      elementType=isOwnedIrType,
      basePointer=valueCell,
      indices=isOwnedGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToIsOwned(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue, metadata : Map[String, Metadata] = Map())  {
    val isOwnedPtr = genPointerToIsOwned(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> isOwnedTbaaNode)
    block.store(toStore, isOwnedPtr, metadata=allMetadata)
  }

  def genLoadFromIsOwned(block : IrBlockBuilder)(valueCell : IrValue, metadata : Map[String, Metadata] = Map()) : IrValue = {
    val isOwnedPtr = genPointerToIsOwned(block)(valueCell)
    val allMetadata = Map("tbaa" -> isOwnedTbaaNode) ++ metadata
    block.load("isOwned")(isOwnedPtr, metadata=allMetadata)
  }

  def genPointerToStream(block : IrBlockBuilder)(valueCell : IrValue) : IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("streamPtr")(
      elementType=streamIrType,
      basePointer=valueCell,
      indices=streamGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToStream(block : IrBlockBuilder)(toStore : IrValue, valueCell : IrValue, metadata : Map[String, Metadata] = Map())  {
    val streamPtr = genPointerToStream(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> streamTbaaNode)
    block.store(toStore, streamPtr, metadata=allMetadata)
  }

  def genLoadFromStream(block : IrBlockBuilder)(valueCell : IrValue, metadata : Map[String, Metadata] = Map()) : IrValue = {
    val streamPtr = genPointerToStream(block)(valueCell)
    val allMetadata = Map("tbaa" -> streamTbaaNode) ++ metadata
    block.load("stream")(streamPtr, metadata=allMetadata)
  }
}

object PortCell extends ConcreteCellType with PortFields {
  val llvmName = "port"
  val irType = UserDefinedType("port")
  val schemeName = "<port-cell>"
  val directSubtypes = Set[CellType]()

  val typeId = 15L

  val typeIdGepIndices = List(0, 0, 0)
  val gcStateGepIndices = List(0, 0, 1)
  val isOwnedGepIndices = List(0, 1)
  val streamGepIndices = List(0, 2)

  val typeIdTbaaNode = NumberedMetadata(83L)
  val gcStateTbaaNode = NumberedMetadata(84L)
  val isOwnedTbaaNode = NumberedMetadata(85L)
  val streamTbaaNode = NumberedMetadata(86L)

  def createConstant(isOwned : Long, stream : IrConstant) : StructureConstant = {
    if (stream.irType != streamIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field stream")
    }

    StructureConstant(List(
      DatumCell.createConstant(typeId=typeId),
      IntegerConstant(isOwnedIrType, isOwned),
      stream
    ), userDefinedType=Some(irType))
  }
}

